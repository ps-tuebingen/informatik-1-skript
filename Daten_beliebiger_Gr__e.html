<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>9&nbsp;Daten beliebiger Größe</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{…}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Informatik 1, WS 2021/<span class="mywbr"> &nbsp;</span>22 Universit&#228;t T&#252;bingen</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Programmieren_mit_Ausdr_cken.html" class="tocviewlink" data-pltdoc="x">Programmieren mit Ausdr&#252;cken</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Programmierer_entwerfen_Sprachen_.html" class="tocviewlink" data-pltdoc="x">Programmierer entwerfen Sprachen!</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Systematischer_Programmentwurf.html" class="tocviewlink" data-pltdoc="x">Systematischer Programmentwurf</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Batchprogramme_und_interaktive_Programme.html" class="tocviewlink" data-pltdoc="x">Batchprogramme und interaktive Programme</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="summentypen.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Alternativen:<span class="mywbr"> &nbsp;</span> Summentypen</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="produkttypen.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Zerlegung:<span class="mywbr"> &nbsp;</span> Produkttypen</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="adts.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Alternativen und Zerlegung:<span class="mywbr"> &nbsp;</span> Algebraische Datentypen</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="bsl-semantics.html" class="tocviewlink" data-pltdoc="x">Bedeutung von BSL</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Daten beliebiger Gr&#246;&#223;e</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="patternmatching.html" class="tocviewlink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Quote_und_Unquote.html" class="tocviewlink" data-pltdoc="x">Quote und Unquote</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="lang-support.html" class="tocviewlink" data-pltdoc="x">Sprachunterst&#252;tzung f&#252;r Datendefinitionen und Signaturen</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="lang-support-adts.html" class="tocviewlink" data-pltdoc="x">Sprachunterst&#252;tzung f&#252;r Algebraische Datentypen</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="DRY__Abstraktion__berall_.html" class="tocviewlink" data-pltdoc="x">DRY:<span class="mywbr"> &nbsp;</span> Abstraktion &#252;berall!</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="Programmieren_mit_Higher-Order_Funktionen.html" class="tocviewlink" data-pltdoc="x">Programmieren mit Higher-<wbr></wbr>Order Funktionen</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Bedeutung_von_ISL_.html" class="tocviewlink" data-pltdoc="x">Bedeutung von ISL+</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Generative_Rekursion.html" class="tocviewlink" data-pltdoc="x">Generative Rekursion</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Akkumulation_von_Wissen.html" class="tocviewlink" data-pltdoc="x">Akkumulation von Wissen</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Daten beliebiger Gr&#246;&#223;e</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">9.1&nbsp;</td><td><a href="#%28part._rekursivedatentypen%29" class="tocviewlink" data-pltdoc="x">Rekursive Datentypen</a></td></tr><tr><td align="right">9.2&nbsp;</td><td><a href="#%28part._programmieren-rekdt%29" class="tocviewlink" data-pltdoc="x">Programmieren mit rekursiven Datentypen</a></td></tr><tr><td align="right">9.3&nbsp;</td><td><a href="#%28part._.Listen%29" class="tocviewlink" data-pltdoc="x">Listen</a></td></tr><tr><td align="right">9.4&nbsp;</td><td><a href="#%28part._.Mehrere_rekursive_.Datentypen_gleichzeitig%29" class="tocviewlink" data-pltdoc="x">Mehrere rekursive Datentypen gleichzeitig</a></td></tr><tr><td align="right">9.5&nbsp;</td><td><a href="#%28part._.Entwurfsrezept_f_r_.Funktionen_mit_rekursiven_.Datentypen%29" class="tocviewlink" data-pltdoc="x">Entwurfsrezept f&#252;r Funktionen mit rekursiven Datentypen</a></td></tr><tr><td align="right">9.6&nbsp;</td><td><a href="#%28part._.Refactoring_von_rekursiven_.Datentypen%29" class="tocviewlink" data-pltdoc="x">Refactoring von rekursiven Datentypen</a></td></tr><tr><td align="right">9.7&nbsp;</td><td><a href="#%28part._.Programm_quivalenz_und_.Induktionsbeweise%29" class="tocviewlink" data-pltdoc="x">Programm&#228;quivalenz und Induktionsbeweise</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">9.1<tt>&nbsp;</tt></span><a href="#%28part._rekursivedatentypen%29" class="tocsubseclink" data-pltdoc="x">Rekursive Datentypen</a></td></tr><tr><td><span class="tocsublinknumber">9.2<tt>&nbsp;</tt></span><a href="#%28part._programmieren-rekdt%29" class="tocsubseclink" data-pltdoc="x">Programmieren mit rekursiven Datentypen</a></td></tr><tr><td><span class="tocsublinknumber">9.3<tt>&nbsp;</tt></span><a href="#%28part._.Listen%29" class="tocsubseclink" data-pltdoc="x">Listen</a></td></tr><tr><td><span class="tocsublinknumber">9.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Listen__hausgemacht%29" class="tocsubseclink" data-pltdoc="x">Listen, hausgemacht</a></td></tr><tr><td><span class="tocsublinknumber">9.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Listen_aus_der_.Konserve%29" class="tocsubseclink" data-pltdoc="x">Listen aus der Konserve</a></td></tr><tr><td><span class="tocsublinknumber">9.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Die_list_.Funktion%29" class="tocsubseclink" data-pltdoc="x">Die <span class="RktSym"><span class="RktValLink">list</span></span> Funktion</a></td></tr><tr><td><span class="tocsublinknumber">9.3.4<tt>&nbsp;</tt></span><a href="#%28part._.Datentypdefinitionen_f_r_.Listen%29" class="tocsubseclink" data-pltdoc="x">Datentypdefinitionen f&#252;r Listen</a></td></tr><tr><td><span class="tocsublinknumber">9.3.5<tt>&nbsp;</tt></span><a href="#%28part._.Aber_sind_.Listen_wirklich_rekursive_.Datenstrukturen_%29" class="tocsubseclink" data-pltdoc="x">Aber sind Listen wirklich rekursive Datenstrukturen?</a></td></tr><tr><td><span class="tocsublinknumber">9.3.6<tt>&nbsp;</tt></span><a href="#%28part._natrec%29" class="tocsubseclink" data-pltdoc="x">Nat&#252;rliche Zahlen als rekursive Datenstruktur</a></td></tr><tr><td><span class="tocsublinknumber">9.4<tt>&nbsp;</tt></span><a href="#%28part._.Mehrere_rekursive_.Datentypen_gleichzeitig%29" class="tocsubseclink" data-pltdoc="x">Mehrere rekursive Datentypen gleichzeitig</a></td></tr><tr><td><span class="tocsublinknumber">9.5<tt>&nbsp;</tt></span><a href="#%28part._.Entwurfsrezept_f_r_.Funktionen_mit_rekursiven_.Datentypen%29" class="tocsubseclink" data-pltdoc="x">Entwurfsrezept f&#252;r Funktionen mit rekursiven Datentypen</a></td></tr><tr><td><span class="tocsublinknumber">9.6<tt>&nbsp;</tt></span><a href="#%28part._.Refactoring_von_rekursiven_.Datentypen%29" class="tocsubseclink" data-pltdoc="x">Refactoring von rekursiven Datentypen</a></td></tr><tr><td><span class="tocsublinknumber">9.7<tt>&nbsp;</tt></span><a href="#%28part._.Programm_quivalenz_und_.Induktionsbeweise%29" class="tocsubseclink" data-pltdoc="x">Programm&#228;quivalenz und Induktionsbeweise</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="bsl-semantics.html" title="backward to &quot;8 Bedeutung von BSL&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Informatik 1, WS 2021/22 Universität Tübingen&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="patternmatching.html" title="forward to &quot;10 Pattern Matching&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>9<tt>&nbsp;</tt><a name="(part._.Daten_beliebiger_.Gr__e)"></a>Daten beliebiger Gr&#246;&#223;e</h3><p>Die Datentypen, die wir bisher gesehen haben, repr&#228;sentieren grunds&#228;tzlich
Daten, die aus einer festen Anzahl von atomaren Daten bestehen. Dies
liegt daran, dass jede Datendefinition nur andere Datendefinitionen verwenden
darf, die vorher bereits definiert wurden. Betrachten wir zum Beispiel</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">gcircle</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">center</span><span class="hspace">&nbsp;</span><span class="RktSym">radius</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A GCircle is (make-gcircle Posn Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. the geometrical representation of a circle</span></td></tr></table></blockquote><p>so wissen wir, dass eine <span class="RktSym">Posn</span> aus zwei und eine <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span>
aus einem atomaren Datum (jeweils Zahlen) besteht und damit
ein <span class="RktSym">GCircle</span> aus genau drei atomaren Daten.</p><p>In vielen Situationen wissen wir jedoch nicht zum Zeitpunkt des Programmierens, aus
wievielen atomaren Daten ein zusammengesetztes Datum besteht. In diesem Kapitel befassen
wir uns damit, wie wir Daten beliebiger (und zum Zeitpunkt des Programmierens unbekannter)
Gr&#246;&#223;e repr&#228;sentieren und Funktionen, die solche Daten verarbeiten, programmieren k&#246;nnen.</p><h4>9.1<tt>&nbsp;</tt><a name="(part._rekursivedatentypen)"></a>Rekursive Datentypen</h4><p>Betrachten wir als Beispiel ein Programm, mit dem Stammb&#228;ume von Personen verwaltet werden k&#246;nnen.
Jede Person im Stammbaum hat einen Vater und eine Mutter; manchmal sind Vater oder Mutter einer
Person auch unbekannt.</p><p>Mit den bisherigen Mitteln k&#246;nnten wir zum Beispiel so vorgehen, um die Vorfahren einer Person zu repr&#228;sentieren:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parent</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span><span class="hspace">&nbsp;</span><span class="RktSym">grandfather</span><span class="hspace">&nbsp;</span><span class="RktSym">grandmother</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Parent is: (make-parent String String String)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. the name of a person with the names of his/her grandparents</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">person</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span><span class="hspace">&nbsp;</span><span class="RktSym">father</span><span class="hspace">&nbsp;</span><span class="RktSym">mother</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Person is: (make-person String Parent Parent)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. the name of a person with his/her parents</span></td></tr></table></blockquote><p>Allerdings k&#246;nnen wir so nur die Vorfahren bis zu genau den Gro&#223;eltern repr&#228;sentieren. Nat&#252;rlich k&#246;nnten wir noch
weitere Definitionen f&#252;r die Urgro&#223;eltern usw. hinzuf&#252;gen, aber stets h&#228;tten wir eine beim Programmieren festgelegte
Gr&#246;&#223;e. Au&#223;erdem versto&#223;en wir gegen das DRY Prinzip, denn die Datendefinitionen sehen f&#252;r jede Vorg&#228;ngergeneration
sehr &#228;hnlich aus.</p><p>Was k&#246;nnen wir machen um mit diesem Problem umzugehen? Betrachten wir etwas genauer, was f&#252;r Daten wir hier eigentlich
modellieren wollen. Die Erkenntnis, die wir hier ben&#246;tigen, ist, dass ein Stammbaum eine rekursive Struktur hat:
Der Stammbaum einer Person besteht aus dem Namen der Person und dem Stammbaum seiner Mutter und dem Stammbaum seiner Eltern.
Ein Stammbaum hat also eine Eigenschaft, die man auch <span style="font-style: italic">Selbst&#228;hnlichkeit</span> nennt: Ein Teil eines Ganzen hat die
gleiche Struktur wie das Ganze.</p><p>Dies bedeutet, dass wir die Restriktion fallen lassen m&#252;ssen, dass in einer Datendefinition nur die Namen bereits vorher
definierter Datentypen auftauchen d&#252;rfen. In unserem Beispiel schreiben wir:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">person</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span><span class="hspace">&nbsp;</span><span class="RktSym">father</span><span class="hspace">&nbsp;</span><span class="RktSym">mother</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A FamilyTree is: (make-person String FamilyTree FamilyTree)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. the name of a person and the tree of his/her parents.</span></td></tr></table></blockquote><p>Die Definition von <span class="RktSym">FamilyTree</span> benutzt also selber wieder <span class="RktSym">FamilyTree</span>.
Erstmal ist nicht ganz klar, was das bedeuten soll. Vor allen Dingen ist aber auch nicht
klar, wie wir einen Stammbaum erzeugen sollen. Wenn wir versuchen, einen zu erzeugen,
bekommen wir ein Problem:</p><p><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktVal">"Bob"</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktVal">"Horst"</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktVal">"Joe"</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p>Wir k&#246;nnen &#252;berhaupt gar keinen Stammbaum erzeugen, weil wir zur Erzeugung bereits einen
Stammbaum haben m&#252;ssen. Ein Ausdruck, der einen Stammbaum erzeugt, w&#228;re also unendlich gro&#223;.</p><p>Bei genauer &#220;berlegung sind Stammb&#228;ume aber niemals unendlich gro&#223;, sondern sie enden bei
irgendeiner Generation - zum Beispiel weil die Vorfahren unbekannt oder nicht von Interesse sind.</p><p>Diesem Tatbestand k&#246;nnen wir dadurch Rechnung tragen, dass wir aus <span class="RktSym">FamilyTree</span> einen
Summentyp machen, und zwar wie folgt:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">person</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span><span class="hspace">&nbsp;</span><span class="RktSym">father</span><span class="hspace">&nbsp;</span><span class="RktSym">mother</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A FamilyTree is either:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (make-person String FamilyTree FamilyTree)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- #false</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. either the name of a person and the tree of its parents,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">or #false if the person is not known/relevant.</span></td></tr></table></blockquote><p>Dieser neue, nicht-rekursive Basisfall erlaubt es uns nun, Werte dieses Typen zu erzeugen.
Hier ist ein Beispiel:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Bob"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Alice"</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Horst"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Joe"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#false</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Rita"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#false</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Was bedeutet also so eine rekursive Datendefinition? Wir haben bisher Datentypen immer
als Mengen von Werten aus dem Datenuniversum interpretiert, und dies ist auch
weiterhin m&#246;glich, nur die Konstruktion der Menge, die der Typ repr&#228;sentiert, ist nun
etwas aufwendiger:</p><p>Sei <span class="texMathInline">ft_0</span> die leere Menge, <span class="texMathInline">ft_1</span> die Menge <span class="texMathInline">\{ \mathtt{\# false} \}</span>, <span class="texMathInline">ft_2</span> die Vereinigung
aus  <span class="texMathInline">\{ \mathtt{\# false} \}</span> und der Menge der <span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span><span class="stt"> </span><span class="RktVal">#false</span><span class="stt"> </span><span class="RktVal">#false</span><span class="RktPn">)</span> f&#252;r alle
Strings <span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span>. Im Allgemeinen sei ft<span style="vertical-align: sub; font-size: 80%">i+1</span> die Vereinigung aus  <span class="texMathInline">\{ \mathtt{\# false} \}</span> und der
Menge der <span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span><span class="stt"> </span><span class="RktSym">p1</span><span class="stt"> </span><span class="RktSym">p2</span><span class="RktPn">)</span> f&#252;r alle Strings <span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28form._world._%28%28lib._2htdp%2Funiverse..rkt%29._name%29%29" class="RktStxLink" data-pltdoc="x">name</a></span> sowie f&#252;r alle <span class="RktSym">p1</span> und
alle <span class="RktSym">p2</span> aus ft<span style="vertical-align: sub; font-size: 80%">i</span>. Beispielsweise ist <span class="RktSym">Bob</span> ein Element von ft<span style="vertical-align: sub; font-size: 80%">5</span> (und
damit auch ft<span style="vertical-align: sub; font-size: 80%">6</span>, ft<span style="vertical-align: sub; font-size: 80%">7</span> usw.) aber nicht von ft<span style="vertical-align: sub; font-size: 80%">4</span>.</p><p>Dann ist die Bedeutung von <span class="RktSym">FamilyTree</span>, <span class="texMathInline">\mathit{ft}</span>, die Vereinigung aller dieser Mengen, also ft<span style="vertical-align: sub; font-size: 80%">0</span>
vereinigt mit <span class="texMathInline">ft_1</span> vereinigt mit <span class="texMathInline">ft_2</span> vereinigt mit <span class="texMathInline">ft_3</span> vereinigt mit ... .</p><p>In mathematischer Schreibweise k&#246;nnen wir die Konstruktion so zusammenfassen:</p><p><span class="texMathInline">\begin{aligned}
  \mathit{ft}_0 &amp; = \emptyset  \\
  \mathit{ft}_{i+1} &amp; = \{ \mathtt{\# false} \} \cup \{ \mathtt{(make-person}\ \mathit{n}\ \mathit{p}_1\ \mathit{p}_2 \mathtt{)} \ |
                 \mathit{n} \in \mathit{String}, \mathit{p}_1 \in \mathit{ft}_{i},  \mathit{p}_2 \in \mathit{ft}_{i} \} \\
  \mathit{ft} &amp; = \bigcup_{i \in \mathbb{N}}{\mathit{ft}_i}
\end{aligned}</span></p><p>Es ist nicht schwer zu sehen, dass stets <span class="texMathInline">\mathit{ft}_i \subseteq \mathit{ft}_{i+1}</span>; die n&#228;chste Menge umfasst
also stets die vorherige.</p><p>Aus dieser Mengenkonstruktion wird klar, wieso rekursive Datentypen es erm&#246;glichen, Daten beliebiger
Gr&#246;&#223;e zu repr&#228;sentieren: Jede Menge ft<span style="vertical-align: sub; font-size: 80%">i</span> enth&#228;lt die Werte, deren maximale Tiefe in Baumdarstellung i ist.
Da wir alle ft<span style="vertical-align: sub; font-size: 80%">i</span> miteinander vereinigen, ist die Tiefe (und damit auch die Gr&#246;&#223;e) unbegrenzt.</p><p>Diese Mengenkonstruktion kann f&#252;r jeden rekursiven Datentyp definiert werden. Falls es mehrere rekursive
Alternativen gibt, so ist die i-te Menge die Vereinigung der i-ten Mengen f&#252;r jede Alternative. G&#228;be es also
beispielsweise noch eine zus&#228;tzliche <span class="RktSym">FamilyTree</span> Alternative <span class="RktPn">(</span><span class="RktSym">make-celebrity</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.String%29%29" class="RktValLink" data-pltdoc="x">String</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym">FamilyTree</span><span class="stt"> </span><span class="RktSym">FamilyTree</span><span class="RktPn">)</span>
bei der neben dem Namen auch noch das Verm&#246;gen angegeben wird, so w&#228;re</p><p><span class="texMathDisplay">\begin{aligned}
  \mathit{ft}_{i+1} &amp; = \{ \mathtt{\# false} \} \cup \{ \mathtt{(make-person}\ \mathit{n}\ \mathit{p}_1\ \mathit{p}_2 \mathtt{)} \ |
                 \mathit{n} \in \mathit{String}, \mathit{p}_1 \in \mathit{ft}_{i},  \mathit{p}_2 \in \mathit{ft}_{i} \} \\
     &amp; \cup \{ \mathtt{(make-celebrity}\ \mathit{n}\ \mathit{w}\ \mathit{p}_1\ \mathit{p}_2 \mathtt{)} \ |
                 \mathit{n} \in \mathit{String}, \mathit{w} \in \mathit{Number}, \mathit{p}_1 \in \mathit{ft}_{i},  \mathit{p}_2 \in \mathit{ft}_{i} \}
\end{aligned}</span></p><h4>9.2<tt>&nbsp;</tt><a name="(part._programmieren-rekdt)"></a>Programmieren mit rekursiven Datentypen</h4><p>Im letzten Abschnitt haben wir gesehen, wie man rekursive Datentypen definiert, was sie bedeuten, und wie man Instanzen
dieser Datentypen erzeugt. Nun wollen wir &#252;berlegen, wie man Funktionen programmieren kann, die Instanzen
solcher Typen als Argumente haben oder als Resultat produzieren.</p><p>Betrachten Sie dazu folgende Aufgabe: Programmieren sie eine Funktion, die herausfindet, ob es im Stammbaum
einer Person einen Vorfahren mit einem bestimmten Namen gibt.</p><p>Eine Signatur, Aufgabenbeschreibung und Tests sind dazu schnell definiert:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">FamilyTree String -&gt; Boolean</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">determines whether person p has an ancestor a</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="hspace">&nbsp;</span><span class="RktVal">"Joe"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#true</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="hspace">&nbsp;</span><span class="RktVal">"Emil"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr></table></blockquote><p>Da <span class="RktSym">FamilyTree</span> ein Summentyp ist, sagt unser Entwurfsrezept, dass wir eine Fallunterscheidung machen.
In jedem Zweig der Fallunterscheidung k&#246;nnen wir die Selektoren f&#252;r die Felder eintragen. In
unserem Beispiel ergibt sich:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">(</span><span class="RktSym">person-name</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Wir interpretieren das Wort "Vorfahr" so, dass eine Person ihr eigener Vorfahr ist. Wie
m&#252;sste das Programm aussehen, um die nicht-reflexive Interpretation des Worts "Vorfahr"
zu realisieren?</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">Die Ausdr&#252;cke <span class="RktPn">(</span><span class="RktSym">person-father</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">)</span> und <span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">)</span> stehen f&#252;r Werte, die einen komplexen
Summentypen, n&#228;mlich wieder <span class="RktSym">FamilyTree</span> haben. Offensichtlich hat eine Person einen Vorfahren
<span class="RktSym">a</span>, wenn die Person entweder selber <span class="RktSym">a</span> ist oder die Mutter oder der Vater einen
Vorfahr mit dem Namen <span class="RktSym">a</span> hat.</div></p><p>Unser Entwurfsrezept schl&#228;gt f&#252;r F&#228;lle, in denen Felder einer Strukur selber einen komplexen Summen-/Produkttyp
haben, vor, eigene Hilfsfunktionen zu definieren. Dies k&#246;nnen wir wie folgt andeuten:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-name</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">father-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mother-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Wenn wir uns jedoch etwas genauer &#252;berlegen, was <span class="RktSym">father-has-ancestor</span> und <span class="RktSym">mother-has-ancestor</span> tun sollen,
stellen wir fest, dass sie die gleiche Signatur und Aufgabenbeschreibung haben wie <span class="RktSym">person-has-ancestor</span>!
Das bedeutet, dass die Templates f&#252;r diese Funktionen wiederum jeweils zwei neue Hilfsfunktionen erfordern. Da wir nicht
wissen, wie tief der Stammbaum ist, k&#246;nnen wir auf diese Weise das Programm also gar nicht realisieren.</p><p>Zum Gl&#252;ck haben wir aber bereits eine Funktion, deren Aufgabe identisch mit der von
<span class="RktSym">father-has-ancestor</span> und <span class="RktSym">mother-has-ancestor</span> ist, n&#228;mlich
<span class="RktSym">person-has-ancestor</span> selbst. Dies motiviert das folgende Template:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-name</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Die Struktur der Daten diktiert also die Struktur der Funktionen. Dort wo die Daten rekursiv sind, sind auch die Funktionen, die solche
Daten verarbeiten, rekursiv.</p><p>Die Vervollst&#228;ndigung des Templates ist nun eifach:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._string~3d~3f%29%29" class="RktValLink" data-pltdoc="x">string=?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-name</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Die erfolgreich ablaufenden Tests illustrieren, dass diese Funktion anscheinend das tut, was sie soll, aber wieso?</p><p>Vergleichen wir die Funktion mit einem anderen Ansatz, der nicht so erfolgreich ist. Betrachten wir nochmal
den Anfang der Programmierung der Funktion, diesmal mit anderem Namen:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">FamilyTree -&gt; Boolean</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">determines whether person p has an ancestor a</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="hspace">&nbsp;</span><span class="RktVal">"Joe"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#true</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="hspace">&nbsp;</span><span class="RktVal">"Emil"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr></table></blockquote><p>Wenn wir schon eine Funktion h&#228;tten, die bestimmen kann, ob eine Person einen bestimmten Vorfahren hat,
k&#246;nnten wir einfach diese Funktion aufrufen. Aber zum Gl&#252;ck sind wir ja schon gerade dabei, diese Funktion
zu programmieren. Also rufen wir doch einfach diese Funktion auf:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">FamilyTree -&gt; Boolean</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">determines whether person p has an ancestor a</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="hspace">&nbsp;</span><span class="RktVal">"Joe"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#true</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="hspace">&nbsp;</span><span class="RktVal">"Emil"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Irgendwie scheint diese L&#246;sung zu einfach zu sein. Ein Ausf&#252;hren der Tests best&#228;tigt den Verdacht.
Allerdings schlagen die Tests nicht fehl, sondern die Ausf&#252;hrung der Tests terminiert nicht und
wir m&#252;ssen sie durch Dr&#252;cken auf die "Stop" Taste abbrechen.</p><p>Wieso funktioniert <span class="RktSym">person-has-ancestor</span> aber nicht <span class="RktSym">person-has-ancestor-stupid</span>?</p><p>Zun&#228;chst einmal k&#246;nnen wir die Programme operationell miteinander vergleichen. Wenn wir den
Ausdruck <span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="stt"> </span><span class="RktSym">Bob</span><span class="stt"> </span><span class="RktVal">"Joe"</span><span class="RktPn">)</span> betrachten, so sagt unsere
Reduktionssemantik:</p><p><span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="stt"> </span><span class="RktSym">Bob</span><span class="stt"> </span><span class="RktVal">"Joe"</span><span class="RktPn">)</span> &#8594; <span class="RktPn">(</span><span class="RktSym">person-has-ancestor-stupid</span><span class="stt"> </span><span class="RktSym">Bob</span><span class="stt"> </span><span class="RktVal">"Joe"</span><span class="RktPn">)</span></p><p>Es gibt also keinerlei Fortschritt bei der Auswertung. Dies erkl&#228;rt, wieso die Ausf&#252;hrung nicht stoppt.</p><p>Dies ist anders bei <span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="stt"> </span><span class="RktSym">Bob</span><span class="stt"> </span><span class="RktVal">"Joe"</span><span class="RktPn">)</span>. Die rekursiven Aufrufe rufen
<span class="RktSym">person-has-ancestor</span> stets auf Vorfahren der Person auf. Da der Stammbaum nur eine endliche
Tiefe hat, muss irgendwann <span class="RktPn">(</span><span class="RktSym">person-has-ancestor</span><span class="stt"> </span><span class="RktVal">#false</span><span class="stt"> </span><span class="RktVal">"Joe"</span><span class="RktPn">)</span> aufgerufen werden, und wir
landen im zweiten Fall des konditionalen Ausdrucks, der keine rekursiven Ausdr&#252;cke mehr enth&#228;lt.</p><p>Wir k&#246;nnen das Programm auch aus Sicht der Bedeutung der rekursiven Datentypdefinition betrachten.
F&#252;r jede Eingabe <span class="RktSym">p</span> gibt es ein minimales i so dass <span class="RktSym">p</span> in ft<span style="vertical-align: sub; font-size: 80%">i</span> ist.
F&#252;r <span class="RktSym">Bob</span> ist dieses i=5. Da die Werte der <span class="RktSym">mother</span> und <span class="RktSym">father</span> Felder von <span class="RktSym">p</span> damit
in <span class="texMathInline">ft_{i-1}</span> sind, ist klar, dass der <span class="RktSym">p</span> Parameter bei allen rekursiven Aufrufe in <span class="texMathInline">ft_{i-1}</span> ist.
Da das Programm offensichtlich f&#252;r Werte aus <span class="texMathInline">ft_0</span> (im Beispiel die Menge {#false}) terminiert, ist
klar, dass dann auch alle Aufrufe mit Werten aus <span class="texMathInline">ft_1</span> terminieren m&#252;ssen, damit dann aber auch
die Aufrufe mit Werten aus <span class="texMathInline">ft_2</span> und so weiter. Damit haben wir gezeigt, dass die Funktion
f&#252;r alle Werte aus <span class="texMathInline">ft_i</span> f&#252;r ein beliebiges i wohldefiniert ist &#8212;<wbr></wbr> mit anderen Worten:
f&#252;r alle Werte aus <span class="RktSym">FamilyTree</span>.</p><p>Dieses informell vorgetragene Argument aus dem vorherigen Absatz ist mathematisch gesehen ein
Induktionsbeweis.</p><p>Bei <span class="RktSym">person-has-ancestor-stupid</span> ist die Lage anders, da im rekursiven Aufruf das Argument
eben nicht aus <span class="texMathInline">ft_{i-1}</span> ist.</p><p>Die Schlussfolgerung aus diesen &#220;berlegungen ist, dass Rekursion in Funktionen unproblematisch
und wohldefiniert ist, solange sie der Struktur der Daten folgt. Da Werte rekursiver
Datentypen eine unbestimmte aber endliche Gr&#246;&#223;e haben, ist diese sogenannte <span style="font-style: italic">strukturelle Rekursion</span>
stets wohldefiniert. Unser Entwurfsrezept schl&#228;gt vor, dass immer dort wo Datentypen rekursiv sind,
auch die Funktionen, die darauf operieren, (strukturell) rekursiv sein sollen.</p><p>Bevor wir uns das angepasste Entwurfsrezept im Detail anschauen, wollen wir erst noch &#252;berlegen, wie
Funktionen aussehen, die Exemplare rekursiver Datentypen <span style="font-style: italic">produzieren</span>.</p><p>Als Beispiel betrachten wir eine Funktion, die sehr n&#252;tzlich ist, um den eigenen Stammbaum etwas
eindrucksvoller aussehen zu lassen, n&#228;mlich eine, mit der der Name aller Vorfahren um einen
Titel erg&#228;nzt werden kann.</p><p>Hier ist die Signatur, Aufgabenbeschreibung und ein Test f&#252;r diese Funktion:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">FamilyTree -&gt; FamilyTree</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">prefixes all members of a family tree p with title t</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="hspace">&nbsp;</span><span class="RktVal">"Dr. "</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVal">"Dr. Bob"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Dr. Alice"</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"Dr. Horst"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Dr. Joe"</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktVal">"Dr. Rita"</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr></table></blockquote><p>Die Funktion konsumiert und produziert also gleichzeitig einen Wert vom Typ <span class="RktSym">FamilyTree</span>.
Das Template f&#252;r solche Funktionen unterscheidet sich nicht von dem f&#252;r
<span class="RktSym">person-has-ancestor</span>. Auch hier wenden wir wieder dort Rekursion an, wo auch der
Datentyp rekursiv ist:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">(</span><span class="RktSym">person-name</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Nun ist es recht einfach, die Funktion zu vervollst&#228;ndigen. Um Werte vom Typ <span class="RktSym">FamilyTree</span>
zu produzieren, bauen wir die Resultate der rekursiven Aufrufe in einen Aufruf
des <span class="RktSym">make-person</span> Konstruktors ein:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._string-append%29%29" class="RktValLink" data-pltdoc="x">string-append</a></span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-name</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">promote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h4>9.3<tt>&nbsp;</tt><a name="(part._.Listen)"></a>Listen</h4><p>Die <span class="RktSym">FamilyTree</span> Datendefinition von oben steht f&#252;r eine Menge von B&#228;umen, in denen
jeder Knoten genau zwei ausgehende Kanten hat. Selbstverst&#228;ndlich k&#246;nnen wir auch auf die
gleiche Weise B&#228;ume repr&#228;sentieren, die drei oder f&#252;nf ausgehende Kanten haben &#8212;<wbr></wbr> indem wir
eine Alternative des Summentyps haben, in der der Datentyp drei bzw. f&#252;nfmal vorkommt.</p><p>Ein besonders wichtiger Spezialfall ist der, wo jeder Knoten genau eine ausgehende Kante hat.
Diese degenerierten B&#228;ume nennt man auch <span style="font-style: italic">Listen</span>.</p><h5>9.3.1<tt>&nbsp;</tt><a name="(part._.Listen__hausgemacht)"></a>Listen, hausgemacht</h5><p>Hier ist eine m&#246;gliche Definition f&#252;r Listen von Zahlen:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">lst</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A List-of-Numbers is either:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (make-lst Number List-Of-Numbers)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- #false</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. the head and rest of a list, or the empty list</span></td></tr></table></blockquote><p>Hier ist ein Beispiel, wie wir eine Liste mit den Zahlen 1 bis 3 erzeugen k&#246;nnen:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote><p>Der Entwurf von Funktionen auf Listen funktioniert genau wie der Entwurf von Funktionen auf
allen anderen B&#228;umen. Betrachten wir als Beispiel eine Funktion, die alle Zahlen in einer
Liste aufaddiert.</p><p>Hier ist die Spezifikation dieser Funktion:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">List-Of-Numbers -&gt; Number</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">adds up all numbers in a list</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr></table></blockquote><p>F&#252;r das Template schl&#228;gt das Entwurfsrezept vor, die verschiedenen Alternativen zu unterscheiden und in den rekursiven
Alternativen rekursive Funktionsaufrufe einzubauen:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">lst?</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-first</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-rest</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Auf Basis dieses Templates ist die Vervollst&#228;ndigung nun einfach:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">lst?</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-first</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-rest</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h5>9.3.2<tt>&nbsp;</tt><a name="(part._.Listen_aus_der_.Konserve)"></a>Listen aus der Konserve</h5><p>Weil Listen so ein h&#228;ufig vorkommender Datentyp sind, gibt es in BSL vordefinierte Funktionen f&#252;r Listen.
Wie <span class="RktSym">List-of-Numbers</span> zeigt, ben&#246;tigen wir diese vordefinierten Funktionen eigentlich nicht, weil wir
Listen einfach als degenerierte B&#228;ume repr&#228;sentieren k&#246;nnen. Dennoch machen die eingebauten Listenfunktionen
das Programmieren mit Listen etwas komfortabler und sicherer.</p><p>Die eingebaute Konstruktorfunktion f&#252;r Listen in BSL hei&#223;t <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span>; die leere Liste wird nicht durch <span class="RktVal">#false</span>
sondern durch die spezielle Konstante <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span> repr&#228;sentiert.</p><p>Es ist sinnvoll, die leere Liste durch einen neuen Wert zu repr&#228;sentieren, der f&#252;r nichts anderes steht, denn dann
kann es niemals zu Verwechslungen kommen. Wenn wir etwas analoges in unserer selbstgebauten Datenstruktur f&#252;r
Listen machen wollten, k&#246;nnten wir dies so erreichen, indem wir eine neue Struktur ohne Felder definieren und
ihren einzigen Wert als Variable definieren:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">empty-lst</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">EMPTYLIST</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-empty-lst</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Dementsprechend w&#252;rde die Beispielliste von oben nun so konstruiert:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktSym">EMPTYLIST</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote><p>Die <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> Operation entspricht unserem <span class="RktSym">make-lst</span>
von oben, allerdings mit einem wichtigen Unterschied: Sie &#252;berpr&#252;ft zus&#228;tzlich, dass das zweite
Argument auch eine Liste ist:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">cons: second argument must be a list, but received 1 and 2</span></p></td></tr></table></blockquote><p>Man kann sich <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> also so vorstellen wie diese selbstgebaute Variante von <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> auf Basis von <span class="RktSym">List-Of-Numbers</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">our-cons</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">empty-lst?</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst?</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-lst</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"second argument of our-cons must be a list"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Die wichtigsten eingebauten Listenfunktionen sind:</p><p><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span>, <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span>, <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span>, <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span>, <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span> und <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons~3f%29%29" class="RktValLink" data-pltdoc="x">cons?</a></span>.</p><p>Sie entsprechen in unserem selbstgebauten Listentyp:</p><p><span class="RktSym">EMPTYLIST</span>, <span class="RktSym">empty-lst?</span>, <span class="RktSym">our-cons</span>, <span class="RktSym">lst-first</span>, <span class="RktSym">lst-rest</span> und <span class="RktSym">lst?</span>.</p><p>Die Funktion, die <span class="RktSym">make-lst</span> entspricht, wird von BSL versteckt, um sicherzustellen, dass alle Listen
stets mit <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> konstruiert werden und dementsprechend die Invariante forciert wird, dass das zweite
Feld der Struktur auch wirklich eine Liste ist. Mit unseren bisherigen Mitteln k&#246;nnen wir dieses "Verstecken"
von Funktionen nicht nachbauen; dazu kommen wir sp&#228;ter, wenn wir &#252;ber Module reden.</p><p>Unser Beispiel von oben sieht bei Nutzung der eingebauten Listenfunktionen also so aus:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A List-of-Numbers is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cons Number List-Of-Numbers)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- empty</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">List-Of-Numbers -&gt; Number</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">adds up all numbers in a list</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons~3f%29%29" class="RktValLink" data-pltdoc="x">cons?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h5>9.3.3<tt>&nbsp;</tt><a name="(part._.Die_list_.Funktion)"></a>Die <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span> Funktion</h5><p>Es stellt sich schnell als etwas m&#252;hselig heraus, Listen mit Hilfe von <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> und <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span> zu konstruieren.
Aus diesem Grund gibt es etwas syntaktischen Zucker, um Listen komfortabler zu erzeugen: Die <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span> Funktion.</p><p>Mit der <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span> Funktion k&#246;nnen wir die Liste <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span> so erzeugen:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></p></blockquote><p>Die <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span> Funktion ist jedoch nur etwas syntaktischer Zucker, der wie folgt definiert ist:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">exp-1</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktSym">exp-n</span><span class="RktPn">)</span></p></blockquote><p>steht f&#252;r n verschachtelte <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> Ausdr&#252;cke:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">exp-1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">exp-n</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote><p>Es ist wichtig, zu verstehen, dass dies wirklich nur eine abk&#252;rzende Schreibweise ist. Auch wenn Sie mittels
<span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span> leichter Listen definieren k&#246;nnen, ist es wichtig, stets im Kopf zu behalten, dass dies nur eine
Kurzschreibweise f&#252;r die Benutzung von <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> und <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span> ist, denn nur so ist das Entwurfsrezept
f&#252;r rekursive Datentypen auch auf Listen anwendbar.</p><h5>9.3.4<tt>&nbsp;</tt><a name="(part._.Datentypdefinitionen_f_r_.Listen)"></a>Datentypdefinitionen f&#252;r Listen</h5><p>Wir haben oben eine Datendefinition <span class="RktSym">List-of-Numbers</span> gesehen. Sollen wir auch f&#252;r <span class="RktSym">List-of-Strings</span>
oder <span class="RktSym">List-of-Booleans</span> eigene Datendefinitionen schreiben? Sollen diese die gleiche Struktur benutzen, oder
sollen wir separate Strukturen f&#252;r jeden dieser Datentypen haben?</p><p>Es ist sinnvoll, dass alle diese Datentypen die gleiche Struktur benutzen, n&#228;mlich in Form der eingebauten
Listenfunktionen. Hierf&#252;r gibt es zwei Gr&#252;nde: Erstens w&#228;ren all diese Strukturen sehr &#228;hnlich und wir w&#252;rden damit
gegen das DRY Prinzip versto&#223;en. Zweitens gibt es eine ganze Reihe von Funktionen, die auf <span style="font-style: italic">beliebigen</span>
Listen arbeiten, zum Beispiel eine Funktion <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span>, die das zweite Listenelement einer Liste zur&#252;ckgibt:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"need at least two list elements"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Diese Funktion (die &#252;brigens schon vordefiniert ist, genau wie <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._third%29%29" class="RktValLink" data-pltdoc="x">third</a></span>, <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._fourth%29%29" class="RktValLink" data-pltdoc="x">fourth</a></span> und so weiter)
funktioniert f&#252;r beliebige Listen, unabh&#228;ngig von der Art der gespeicherten Daten. Solche Funktionen k&#246;nnten wir
nicht schreiben, wenn wir je nach Typ der Listenelemente andere Strukturen verwenden w&#252;rden.</p><p>Der h&#228;ufigste Anwendungsfall von Listen ist der, dass die Listen <span style="font-style: italic">homogen</span> sind. Das bedeutet, dass
alle Listenelemente einen gemeinsamen Typ haben. Dies ist keine sehr gro&#223;e Einschr&#228;nkung, denn dieser
gemeinsame Typ kann beispielsweise auch ein Summentyp mit vielen Alternativen sein. F&#252;r diesen Fall
verwenden wir Datendefinitionen mit <span style="font-style: italic">Typparametern</span>, und zwar so:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A (List-of X) is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cons X (List-of X)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- empty</span></td></tr></table></blockquote><p>Diese Datendefinitionen benutzen wir, indem wir einen Typ f&#252;r den Typparameter angeben. Hierzu
verwenden wir die Syntax f&#252;r Funktionsanwendung; wir schreiben also <span class="RktPn">(</span><span class="RktSym">List-of</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.String%29%29" class="RktValLink" data-pltdoc="x">String</a></span><span class="RktPn">)</span>, <span class="RktPn">(</span><span class="RktSym">List-of</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Boolean%29%29" class="RktValLink" data-pltdoc="x">Boolean</a></span><span class="RktPn">)</span>,
<span class="RktPn">(</span><span class="RktSym">List-of</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">List-of</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.String%29%29" class="RktValLink" data-pltdoc="x">String</a></span><span class="RktPn">)</span><span class="RktPn">)</span> oder <span class="RktPn">(</span><span class="RktSym">List-of</span><span class="stt"> </span><span class="RktSym">FamilyTree</span><span class="RktPn">)</span> und meinen damit implizit
die oben angef&#252;hrte Datendefinition.</p><p>Was aber ist ein geeigneter Datentyp f&#252;r die Signatur von <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span> oben, also im Allgemeinen
f&#252;r Funktionen, die auf beliebigen Listen funktionieren?</p><p>Um deutlich zu machen, dass die Funktionen f&#252;r Listen mit beliebigem Elementtyp funktionieren, sagen wir
dies in der Signatur explizit. Im Beispiel der Funktion <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span> sieht das so aus:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">[X] (List-of X) -&gt; X</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Das [X] am Anfang der Signatur sagt, dass diese Funktion die nachfolgende Signatur f&#252;r jeden Typ X hat,
also (List-of X) -&gt; X f&#252;r jede m&#246;gliche Ersetzung von X durch einen Typen.
Man nennt Variablen wie <span class="RktSym">X</span>  <span style="font-style: italic">Typvariablen</span>.
Also hat <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span> zum Beispiel den Typ (List-of Number) -&gt; Number oder (List-of (List-of String)) -&gt; (List-of String).</div></p><p>Allerdings werden wir im Moment nur im Ausnahmefall Funktionen wie <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span> selber programmieren.
Die meisten Funktionen, die wir im Moment programmieren wollen, verarbeiten Listen mit einem konkreten Elementtyp.
Auf sogenannte <span style="font-style: italic">polymorphe</span> Funktionen wie <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._second%29%29" class="RktValLink" data-pltdoc="x">second</a></span> werden wir sp&#228;ter noch zur&#252;ckkommen.</p><h5>9.3.5<tt>&nbsp;</tt><a name="(part._.Aber_sind_.Listen_wirklich_rekursive_.Datenstrukturen_)"></a>Aber sind Listen wirklich rekursive Datenstrukturen?</h5><p>Wenn man sich Listen aus der realen Welt anschaut (auf einem Blatt Papier, in einer Tabellenkalkulation etc.),
so suggerieren diese h&#228;ufig keine rekursive, verschachtelte Struktur sondern sehen "flach" aus. Ist es also
"nat&#252;rlich", Listen so wie wir es getan haben, &#252;ber einen rekursiven Datentyp - als degenerierten Baum - zu definieren?</p><p>In vielen (vor allem &#228;lteren) Programmiersprachen gibt es eine direktere Unterst&#252;tzung f&#252;r Listen. Listen sind in
diesen Programmiersprachen fest eingebaut. Listen sind in diesen Sprachen nicht rekursiv; stattdessen wird h&#228;ufig &#252;ber
einen Index auf die Elemente der Liste zugegriffen. Um die Programmierung mit Listen zu unterst&#252;tzen, gibt es
einen ganzen Satz von Programmiersprachenkonstrukten (wie z.B. verschiedenen Schleifen- und Iterationskonstrukten),
die der Unterst&#252;tzung dieser fest eingebauten Listen dienen.</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Es gibt allerdings auch durchaus Situationen, in denen rekursiv aufgebaute Listen effizienter
sind. Mehr dazu sp&#228;ter.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">Aus Hardware-Sicht sind solche Listen, &#252;ber die man mit einem Index zugreift, sehr nat&#252;rlich, denn sie entsprechen
gut dem von der Hardware unterst&#252;tzen Zugriff auf den Hauptspeicher.
Insofern sind diese speziellen Listenkonstrukte zum Teil durch ihre Effizienz begr&#252;ndet. Es gibt auch in Racket
(allerdings nicht in BSL) solche Listen; dort hei&#223;en sie <span style="font-style: italic">Vektoren</span>.</div></p><p>Der Reiz der rekursiven Formulierung liegt darin, dass man keinerlei zus&#228;tzliche Unterst&#252;tzung f&#252;r Listen in der
Programmiersprache ben&#246;tigt. Wir haben ja oben gesehen, dass wir uns die Art von Listen, die von BSL direkt
unterst&#252;tzt werden, auch selber programmieren k&#246;nnen. Es ist einfach "yet another recursive datatype", und alle
Konstrukte, Entwurfsrezepte und so weiter funktionieren nahtlos auch f&#252;r Listen. Wir brauchen keine speziellen
Schleifen oder andere Spezialkonstrukte um Listen zu verarbeiten, sondern machen einfach das, was wir auch
bei jedem anderen rekursiven Datentyp machen. Das ist bei fest eingebauten
Index-basierten Listen anders; es gibt viele Beispiele f&#252;r Sprachkonstrukte, die f&#252;r "normale Werte" funktionieren,
aber nicht f&#252;r Listen, und umgekehrt.</p><p>BSL und Racket stehen in der Tradition der Programmiersprache <span style="font-style: italic">Scheme</span>. Die Philosophie, die im ersten
Satz der Sprachspezifikation von Scheme (<a href="http://www.r6rs.org"><span class="url">http://www.r6rs.org</span></a>) zu finden ist, ist damit auch f&#252;r BSL und Racket g&#252;ltig:</p><p><span style="font-style: italic">Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses
and restrictions that make additional features appear necessary. Scheme demonstrates that a very small number of
rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient
programming language that is flexible enough to support most of the major programming paradigms in use today.</span></p><p>Die Behandlung von Listen als rekursive Datentypen ist ein Beispiel f&#252;r diese Philosophie.</p><p>Manche Programmieranf&#228;nger finden es nicht intuitiv, Listen und Funktionen darauf rekursiv zu formulieren.
Aber ist es nicht besser, ein Universalwerkzeug zu verwenden, welches in sehr vielen Situationen verwendbar ist,
als ein Spezialwerkzeug, das in nichts besser ist als das Universalwerkzeug und nur in einer Situation anwendbar ist?</p><h5>9.3.6<tt>&nbsp;</tt><a name="(part._natrec)"></a>Nat&#252;rliche Zahlen als rekursive Datenstruktur</h5><p>Es gibt in BSL nicht nur Funktionen, die Listen konsumieren, sondern auch solche, die Listen
produzieren. Eine davon ist <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._make-list%29%29" class="RktValLink" data-pltdoc="x">make-list</a></span>. Hier ein Beispiel:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._make-list%29%29" class="RktValLink" data-pltdoc="x">make-list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">"abc"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">("abc" "abc" "abc" "abc")</span></p></td></tr></table></blockquote><p>Die <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._make-list%29%29" class="RktValLink" data-pltdoc="x">make-list</a></span> Funktion konsumiert also eine nat&#252;rliche Zahl n und einen Wert und produziert eine Liste mit n Wiederholungen
des Werts. Obwohl diese Funktion also nur atomare Daten konsumiert, produziert sie ein beliebig gro&#223;es
Resultat. Wie ist das m&#246;glich?</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Auch in der Mathematik werden nat&#252;rliche Zahlen &#228;hnlich rekursiv definiert. Recherchieren
sie, was die <span style="font-style: italic">Peano-Axiome</span> sind.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">Eine erleuchtende Antwort darauf ist, dass man auch nat&#252;rliche Zahlen als Instanzen eines rekursiven Datentyps
ansehen kann. Hier ist eine m&#246;gliche Definition:</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Nat (Natural Number) is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#8211; 0</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#8211; (add1 Nat)</span></td></tr></table></blockquote><p>Beispielsweise k&#246;nnen wir die Zahl <span class="RktVal">3</span> repr&#228;sentieren als <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span><span class="stt"> </span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span>. Die <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span>
Funktion hat also eine Rolle &#228;hnlich zu den Konstruktorfunktionen bei Strukturen. Die Rolle der Selektorfunktion
wird durch die Funktion <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._sub1%29%29" class="RktValLink" data-pltdoc="x">sub1</a></span> &#252;bernommen. Das Pr&#228;dikat f&#252;r die erste Alternative von Nat ist <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._zero~3f%29%29" class="RktValLink" data-pltdoc="x">zero?</a></span>;
das Pr&#228;dikat f&#252;r die zweite Alternative hei&#223;t <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._positive~3f%29%29" class="RktValLink" data-pltdoc="x">positive?</a></span>.</p><p>Mit dieser Sichtweise sind wir nun in der Lage, mit unserem Standard-Entwurfsrezept Funktionen wie <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._make-list%29%29" class="RktValLink" data-pltdoc="x">make-list</a></span>
selber zu definieren. Nennen wir unsere Variante von <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._make-list%29%29" class="RktValLink" data-pltdoc="x">make-list</a></span> <span class="RktSym">iterate-value</span>. Hier ist
die Spezifikation:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">[X] Nat X -&gt; (List-of X)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">creates a list with n occurences of x</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">iterate-value</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">"abc"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"abc"</span><span class="hspace">&nbsp;</span><span class="RktVal">"abc"</span><span class="hspace">&nbsp;</span><span class="RktVal">"abc"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">iterate-value</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr></table></blockquote><p>Gem&#228;&#223; unseres Entwurfsrezepts f&#252;r rekursive Datentypen erhalten wir folgendes Template:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">iterate-value</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._zero~3f%29%29" class="RktValLink" data-pltdoc="x">zero?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._positive~3f%29%29" class="RktValLink" data-pltdoc="x">positive?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">iterate-value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._sub1%29%29" class="RktValLink" data-pltdoc="x">sub1</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Dieses Template zu vervollst&#228;ndigen ist nun nur noch ein kleiner Schritt:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">iterate-value</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._zero~3f%29%29" class="RktValLink" data-pltdoc="x">zero?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._positive~3f%29%29" class="RktValLink" data-pltdoc="x">positive?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">iterate-value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._sub1%29%29" class="RktValLink" data-pltdoc="x">sub1</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h4>9.4<tt>&nbsp;</tt><a name="(part._.Mehrere_rekursive_.Datentypen_gleichzeitig)"></a>Mehrere rekursive Datentypen gleichzeitig</h4><p>Ein schwierigerer Fall ist es, wenn mehrere Parameter einer Funktion einen rekursiven Datentyp haben. In diesem Fall ist es meist
sinnvoll, einen dieser Parameter zu bevorzugen und zu ignorieren, dass andere Parameter ebenfalls rekursiv sind. Welcher
Parameter bevorzugt werden sollte, ergibt sich aus der Fragestellung, wie Sie die Eingabe der Funktion am sinnvollsten zerlegen
k&#246;nnen, so dass Sie aus dem Ergebnis des rekursiven Aufrufs und den anderen Parametern am einfachsten das Gesamtergebnis
berechnen k&#246;nnen.</p><p><div class="SIntrapara">Betrachten wir als Beispiel eine Funktion zur Konkatenation von zwei Listen. Diese Funktion ist unter dem Namen <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._append%29%29" class="RktValLink" data-pltdoc="x">append</a></span>
bereits eingebaut, aber wir bauen sie mal nach. Wir haben zwei Parameter, die beide rekursive Datentypen haben.
Eine M&#246;glichkeit w&#228;re, den ersten Parameter zu bevorzugen. Damit erhalten wir folgendes Template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">[X] (list-of X) (list-of X) -&gt; (list-of X)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">concatenates l1 and l2</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">...l2...</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons~3f%29%29" class="RktValLink" data-pltdoc="x">cons?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Tats&#228;chlich ist es in diesem Fall leicht, das Template zu vervollst&#228;ndigen. Wenn wir das Ergebnis von
<span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="stt"> </span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">l2</span><span class="RktPn">)</span> haben, so m&#252;ssen wir nur noch <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="stt"> </span><span class="RktSym">l1</span><span class="RktPn">)</span> vorne anh&#228;ngen:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons~3f%29%29" class="RktValLink" data-pltdoc="x">cons?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">Spielen wir jetzt einmal die zweite M&#246;glichkeit durch: Wir bevorzugen den zweiten Parameter. Damit ergibt
sich folgendes Template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="hspace">&nbsp;</span><span class="RktSym">l1</span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">...l1...</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons~3f%29%29" class="RktValLink" data-pltdoc="x">cons?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._....%29%29" class="RktStxLink" data-pltdoc="x">..</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Der Basisfall ist zwar trivial, aber im rekursiven Fall ist es nicht offensichtlich, wie wir das Template vervollst&#228;ndigen k&#246;nnen. Betrachten wir beispielsweise
den rekursiven Aufruf <span class="RktPn">(</span><span class="RktSym">lst-append</span><span class="stt"> </span><span class="RktSym">l1</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="stt"> </span><span class="RktSym">l2</span><span class="RktPn">)</span><span class="RktPn">)</span>, so k&#246;nnen wir &#252;berlegen, dass uns dieses Ergebnis
&#252;berhaupt nicht weiterhilft, denn wir m&#252;ssten ja irgendwo in der Mitte (aber wo genau ist nicht klar) des Ergebnisses
noch <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="stt"> </span><span class="RktSym">l2</span><span class="RktPn">)</span> einf&#252;gen.</div></p><h4>9.5<tt>&nbsp;</tt><a name="(part._.Entwurfsrezept_f_r_.Funktionen_mit_rekursiven_.Datentypen)"></a>Entwurfsrezept f&#252;r Funktionen mit rekursiven Datentypen</h4><p>Wir haben gesehen, wie wir mit Hilfe eines Entwurfsrezepts einfache Funktionen
(<a href="Systematischer_Programmentwurf.html#%28part._entwurfsrezept%29" data-pltdoc="x">Entwurfsrezept zur Funktionsdefinition</a>), Funktionen mit Summentypen (<a href="summentypen.html#%28part._entwurfsrezept-summen%29" data-pltdoc="x">Entwurf mit Summentypen</a>),
Funktionen mit Produkttypen (<a href="produkttypen.html#%28part._entwurfsrezept-structs%29" data-pltdoc="x">Erweiterung des Entwurfsrezepts</a>) und Funktionen mit
algebraischen Datentypen (<a href="adts.html#%28part._entwurfsrezept-adt%29" data-pltdoc="x">Programmentwurf mit ADTs</a>) entwerfen.</p><p>An dieser Stelle fassen wir zusammen, wie wir das Entwurfsrezept erweitern, um mit Daten beliebiger Gr&#246;&#223;e umzugehen.</p><ol><li><p>Wenn es in der Problemdom&#228;ne Informationen unbegrenzter Gr&#246;&#223;e gibt, ben&#246;tigen
Sie eine selbstreferenzierende Datendefinition. Damit eine selbstreferenzierende
Datendefinition g&#252;ltig ist, muss sie drei Bedingungen erf&#252;llen: 1) Der Datentyp
ist ein Summentyp. 2) Es muss mindestens
zwei Alternativen geben. 3) Mindestens eine der Alternativen referenziert nicht den
gerade definierten Datentyp, ist also nicht rekursiv.</p><p>Sie sollten f&#252;r rekursive Datentypen Datenbeispiele angeben, um zu validieren,
dass Ihre Definition sinnvoll ist. Wenn es nicht offensichtlich ist, wie Sie ihre
Datenbeispiele beliebig gro&#223; machen, stimmt vermutlich etwas nicht.</p></li><li><p>Beim zweiten Schritt &#228;ndert sich nichts: Sie ben&#246;tigen wie immer eine Signatur, eine
Aufgabenbeschreibung und eine Dummy-Implementierung.</p></li><li><p>Bei selbstreferenzierenden Datentypen ist es nicht mehr m&#246;glich, f&#252;r jede Alternative
einen Testfall anzugeben (weil es, wenn man in die Tiefe geht, unendlich viele Alternativen gibt).
Die Testf&#228;lle sollten auf jeden Fall alle Teile der Funktion abdecken. Versuchen Sie weiterhin,
kritische Grenzf&#228;lle zu identifizieren und zu testen.</p></li><li><p>Rekursive Datentypen sind algebraische Datentypen, daher kann f&#252;r den
Entwurf des Templates die Methodik aus <a href="adts.html#%28part._entwurfsrezept-adt%29" data-pltdoc="x">Programmentwurf mit ADTs</a> angewendet
werden. Die wichtigste Erg&#228;nzung zu dem Entwurfsrezept betrifft den Fall, dass eine
Alternative implementiert werden muss, die selbstreferenzierend ist. Statt wie sonst
eine neue Hilfsfunktion im Template zu verwenden, wird in diesem Fall ein rekursiver
Aufruf der Funktion, die Sie gerade implementieren, ins Template aufgenommen. Als Argument
des rekursiven Aufrufs wird der Aufruf des Selektors, der den zur Datenrekursion geh&#246;rigen
Wert extrahiert, ins Template mit aufgenommen. Wenn Sie beispielsweise eine Funktion
<span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">a-list-of-strings</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span> auf Listen definieren, so sollte im <span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cons~3f%29%29" class="RktValLink" data-pltdoc="x">cons?</a></span>
Fall der Funktion der Aufruf <span class="RktPn">(</span><span class="RktSym">f</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="stt"> </span><span class="RktSym">a-list-of-strings</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span> stehen.</p></li><li><p>Beim Entwurf des Funktionsbodies starten wir mit den F&#228;llen der Funktion, die nicht rekursiv sind.
Diese F&#228;lle nennt man auch die <span style="font-style: italic">Basisf&#228;lle</span>, in Analogie zu Basisf&#228;llen bei Beweisen per Induktion.
Die nicht-rekursiven F&#228;lle sind typischerweise einfach und sollten sich direkt aus den Testf&#228;llen ergeben.</p><p>In den rekursiven F&#228;llen m&#252;ssen wir uns &#252;berlegen, was der rekursive Aufruf bedeutet. Hierzu nehmen wir an,
dass der rekursive Aufruf die Funktion korrekt berechnet, so wie wir es in der Aufgabenbeschreibung in Schritt 2
festgelegt haben. Mit diesem Wissen m&#252;ssen wir nun nur noch die zur Verf&#252;gung stehenden Werte zur L&#246;sung
zusammenbauen.</p></li><li><p>Testen Sie wie &#252;blich, ob ihre Funktion wie gew&#252;nscht funktioniert und pr&#252;fen Sie, ob die Tests alle interessanten F&#228;lle abdecken.</p></li><li><p>F&#252;r Programme mit rekursiven Datentypen gibt es einige neue Refactorings, die m&#246;glicherweise sinnvoll sind.
&#220;berpr&#252;fen Sie, ob ihr Programm Datentypen enth&#228;lt, die nicht rekursiv sind, aber die durch einen rekursiven
Datentyp vereinfacht werden k&#246;nnten. Enth&#228;lt ihr Programm beispielsweise separate Datentypen f&#252;r Angestellter, Gruppenleiter, Abteilungsleiter,
Bereichsleiter und so weiter, so k&#246;nnte dies durch einen rekursiven Datentyp, mit dem beliebig tiefe Managementhierarchien
modelliert werden k&#246;nnen, vereinfacht werden.</p></li></ol><h4>9.6<tt>&nbsp;</tt><a name="(part._.Refactoring_von_rekursiven_.Datentypen)"></a>Refactoring von rekursiven Datentypen</h4><p>Bez&#252;glich der Datentyp-Refactorings aus <a href="adts.html#%28part._refactoring-adt%29" data-pltdoc="x">Refactoring von algebraischen Datentypen</a> ergeben sich neue
        Typisomorphien durch "inlining" bzw. Expansion von rekursiven Datendefinitionen. Beispielsweise ist in folgendem Beispiel
        <span class="RktSym">list-of-number</span> isomorph zu <span class="RktSym">list-of-number2</span>, denn letztere Definition ergibt sich aus der ersten
        indem man die Rekursion einmal expandiert.</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A list-of-number is either:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- empty</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cons Number list-of-number)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Number-and-Number-List</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktSym">numlist</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A list-of-number2 is either:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- empty</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (make-Number-and-Number-List Number list-of-number)</span></td></tr></table></blockquote></div><div class="SIntrapara">Versuchen Sie, Definitionen wie <span class="RktSym">list-of-number2</span> zu vermeiden, denn Funktionen, die darauf definiert sind, sind komplexer als solche,
die <span class="RktSym">list-of-number</span> verwenden.</div></p><p>Wenn wir die Notation aus <a href="adts.html#%28part._refactoring-adt%29" data-pltdoc="x">Refactoring von algebraischen Datentypen</a> verwenden, so k&#246;nnen wir rekursive Datentypen als Funktionen modellieren, wobei der
Funktionsparameter das rekursive Vorkommen des Datentyps modelliert. Beispielsweise kann der Datentyp der Listen von Zahlen durch die
Funktion <span class="RktSym">F</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">X</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym">X</span><span class="RktPn">)</span><span class="RktPn">)</span> modelliert werden<span class="NoteBox"><span class="NoteContent">Solche Funktionen nennt man auch <span style="font-style: italic">Funktoren</span> und sie sind
in der universellen Algebra als <span style="font-style: italic">F-Algebras</span> von wichtiger Bedeutung.</span></span>. Das sch&#246;ne an dieser Notation ist, dass man sehr leicht
definieren kann, wann rekursive Datentypen isormoph sind. Die Expansion eines rekursiven Datentyps ergibt sich daraus, den Funktionsparameter
<span class="RktSym">X</span> durch die rechte Seite der Definition zu ersetzen, also in dem Beispiel <span class="RktSym">F</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">X</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym">X</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span>.
Inlining ist die umgekehrte Operation. Die Rechtfertigung f&#252;r diese Operationen ergibt sich daraus, dass man rekursive Datentypen
als kleinsten Fixpunkt solcher Funktoren verstehen kann. Beispielsweise ist der kleinste Fixpunkt von
<span class="RktSym">F</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">X</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym">X</span><span class="RktPn">)</span><span class="RktPn">)</span> die unendliche Summe <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._.Number%29%29" class="RktValLink" data-pltdoc="x">Number</a></span><span class="stt"> </span><span class="RktSym">Empty</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span>.
Der kleinste Fixpunkt &#228;ndert sich durch Expansion oder Inlining nicht, daher sind solche Datentypen isomorph.</p><h4>9.7<tt>&nbsp;</tt><a name="(part._.Programm_quivalenz_und_.Induktionsbeweise)"></a>Programm&#228;quivalenz und Induktionsbeweise</h4><p>Betrachten Sie die folgenden beiden Funktionen:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">FamilyTree -&gt; Number</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">computes the number of known ancestors of p</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">FamilyTree -&gt; Number</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">computes the number of unknown ancestors of p</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._check-expect%29%29" class="RktStxLink" data-pltdoc="x">check-expect</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">Bob</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Die Tests suggerieren, dass f&#252;r alle Personen <span class="RktSym">p</span> folgende &#196;quivalenz gilt: <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="stt"> </span><span class="RktSym">p</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> &#8801; <span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="stt"> </span><span class="RktSym">p</span><span class="RktPn">)</span>.
Aber wie k&#246;nnen wir zeigen, dass diese Eigenschaft tats&#228;chlich stimmt?</p><p>Das Schliessen durch Gleichungen, wie wir es in <a href="bsl-semantics.html#%28part._equationalreasoning%29" data-pltdoc="x">Refactoring von Ausdr&#252;cken und Schliessen durch Gleichungen</a> kennengelernt haben, reicht hierzu alleine nicht aus.
Dadurch, dass die Funktionen rekursiv sind, k&#246;nnen wir durch <span style="font-style: italic">EFUN</span> immer gr&#246;&#223;ere Terme erzeugen, aber wir kommen niemals
von <span class="RktSym">numKnownAncestors</span> zu <span class="RktSym">numUnknownAncestors</span>.</p><p>Bei strukturell rekursiven Funktionen auf rekursiven Datentypen k&#246;nnen wir jedoch ein weiteres, sehr m&#228;chtiges Beweisprinzip verwenden, n&#228;mlich das
Prinzip der <span style="font-style: italic">Induktion</span>. Betrachten Sie nochmal die Mengenkonstruktion der ft<span style="vertical-align: sub; font-size: 80%">i</span> aus <a href="#%28part._rekursivedatentypen%29" data-pltdoc="x">Rekursive Datentypen</a>. Wir wissen,
dass der Typ FamilyTree die Vereinigung aller ft<span style="vertical-align: sub; font-size: 80%">i</span> ist. Desweiteren wissen wir, dass, wenn <span class="RktSym">p</span> in ft<span style="vertical-align: sub; font-size: 80%">i+1</span> ist, dann ist
<span class="RktPn">(</span><span class="RktSym">person-father</span><span class="stt"> </span><span class="RktSym">p</span><span class="RktPn">)</span> und <span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="stt"> </span><span class="RktSym">p</span><span class="RktPn">)</span> in ft<span style="vertical-align: sub; font-size: 80%">i</span>. Dies rechtfertigt die Verwendung des Beweisprinzips der Induktion:
Wir zeigen die gew&#252;nschte &#196;quivalenz f&#252;r den Basisfall i = 1, also <span class="RktSym">p</span> = <span class="RktVal">#false</span>. Dann zeigen wir die &#196;quivalenz f&#252;r den Fall i = n+1,
unter der Annahme, dass die &#196;quivalenz bereits f&#252;r i = n gilt. Anders ausgedr&#252;ckt zeigen wir f&#252;r die &#196;quivalenz f&#252;r den Fall
<span class="RktSym">p</span> = <span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">p1</span><span class="stt"> </span><span class="RktSym">p2</span><span class="RktPn">)</span> unter der Annahme, dass die &#196;quivalenz f&#252;r <span class="RktSym">p1</span> und <span class="RktSym">p2</span> gilt.</p><p>Typischerweise l&#228;&#223;t man bei dieser Art von Induktionsbeweisen die Mengenkonstruktion mit ihren Indizes weg und "&#252;bersetzt" die Indizes direkt in die
Datentyp-Notation. Dies bedeutet, dass man die gew&#252;nschte Aussage zun&#228;chst f&#252;r die nicht-rekursiven F&#228;lle des Datentyps zeigt, und dann im Induktionsschritt
die Aussage f&#252;r die rekursiven F&#228;lle zeigt unter der Annahme, dass die Aussage f&#252;r die Unterkomponenten des Datentyps bereits gilt. Diese Art
des Induktionsbeweises nennt man auch <span style="font-style: italic">strukturelle Induktion</span>.</p><p>Wir wollen beweisen: <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="stt"> </span><span class="RktSym">p</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> &#8801; <span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="stt"> </span><span class="RktSym">p</span><span class="RktPn">)</span> f&#252;r alle Personen <span class="RktSym">p</span>.
Betrachten wir zun&#228;chst den Basisfall <span class="RktSym">p</span> = <span class="RktVal">#false</span>.</p><p>Dann k&#246;nnen wir schliessen:</p><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="stt"> </span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">EFUN</span> und <span style="font-style: italic">EKONG</span>)</p><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="stt"> </span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="stt"> </span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">STRUCT-predfalse</span> und <span style="font-style: italic">EKONG</span>)</p><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="stt"> </span><span class="RktPn">[</span><span class="RktVal">#false</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="stt"> </span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">COND-False</span> und <span style="font-style: italic">EKONG</span>)</p><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="stt"> </span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">COND-True</span> und <span style="font-style: italic">EKONG</span>)</p><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">0</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">PRIM</span>)</p><p><span class="RktVal">1</span></p><p>Unter Nutzung von <span style="font-style: italic">ETRANS</span> k&#246;nnen wir damit <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="stt"> </span><span class="RktVal">#false</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> &#8801; <span class="RktVal">1</span> schliessen.
Auf die gleiche Weise k&#246;nnen wir schliessen: <span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="stt"> </span><span class="RktVal">#false</span><span class="RktPn">)</span> &#8801; <span class="RktVal">1</span>. Damit haben wir den Basisfall gezeigt.</p><p>F&#252;r den Induktionsschritt m&#252;ssen wir die &#196;quivalenz f&#252;r <span class="RktSym">p</span> = <span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">p1</span><span class="stt"> </span><span class="RktSym">p2</span><span class="RktPn">)</span> zeigen und d&#252;rfen hierbei verwenden,
dass die Aussage f&#252;r <span class="RktSym">p1</span> und <span class="RktSym">p2</span> gilt, also <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="stt"> </span><span class="RktSym">p1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> &#8801; <span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="stt"> </span><span class="RktSym">p1</span><span class="RktPn">)</span>
und <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="stt"> </span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> &#8801; <span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="stt"> </span><span class="RktSym">p2</span><span class="RktPn">)</span>.</p><p>Wir k&#246;nnen nun wie folgt schliessen:</p><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">p1</span><span class="stt"> </span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">EFUN</span> und <span style="font-style: italic">EKONG</span>)</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr></table></blockquote><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">STRUCT-predtrue</span> und <span style="font-style: italic">EKONG</span>)</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">#true</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr></table></blockquote><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">COND-True</span> und <span style="font-style: italic">EKONG</span>)</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr></table></blockquote><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">STRUCT-select</span> und <span style="font-style: italic">EKONG</span>)</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr></table></blockquote><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">EPRIM</span>)</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numKnownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>&#8801; (gem&#228;&#223; Induktionsannahme und <span style="font-style: italic">EKONG</span>)</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">STRUCT-select</span> und <span style="font-style: italic">EKOMM</span> und <span style="font-style: italic">EKONG</span>)</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/beginner.html#%28def._htdp-beginner._%28%28lib._lang%2Fhtdp-beginner..rkt%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-father</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person-mother</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>&#8801; (gem&#228;&#223; <span style="font-style: italic">EFUN</span> und <span style="font-style: italic">EKOMM</span>)</p><p><span class="RktPn">(</span><span class="RktSym">numUnknownAncestors</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">make-person</span><span class="stt"> </span><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">p1</span><span class="stt"> </span><span class="RktSym">p2</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p>Damit haben wir (unter Nutzung von <span style="font-style: italic">ETRANS</span>) die &#196;quivalenz bewiesen. Dieser Beweis ist sehr ausf&#252;hrlich und kleinschrittig.
Wenn Sie ge&#252;bter im Nutzen von Programm&#228;quivalenzen sind, werden ihre Beweise gro&#223;schrittiger und damit
auch kompakter.</p><p>Die gleiche Beweismethodik l&#228;sst sich f&#252;r alle rekursiven Datentypen anwenden. Insbesondere l&#228;sst sie sich auch f&#252;r Listen anwenden.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="bsl-semantics.html" title="backward to &quot;8 Bedeutung von BSL&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Informatik 1, WS 2021/22 Universität Tübingen&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="patternmatching.html" title="forward to &quot;10 Pattern Matching&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>