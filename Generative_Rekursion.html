<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>17&nbsp;Generative Rekursion</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Informatik 1, WS 2021/<span class="mywbr"> &nbsp;</span>22 Universit&#228;t T&#252;bingen</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Programmieren_mit_Ausdr_cken.html" class="tocviewlink" data-pltdoc="x">Programmieren mit Ausdr&#252;cken</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Programmierer_entwerfen_Sprachen_.html" class="tocviewlink" data-pltdoc="x">Programmierer entwerfen Sprachen!</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Systematischer_Programmentwurf.html" class="tocviewlink" data-pltdoc="x">Systematischer Programmentwurf</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Batchprogramme_und_interaktive_Programme.html" class="tocviewlink" data-pltdoc="x">Batchprogramme und interaktive Programme</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="summentypen.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Alternativen:<span class="mywbr"> &nbsp;</span> Summentypen</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="produkttypen.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Zerlegung:<span class="mywbr"> &nbsp;</span> Produkttypen</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="adts.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Alternativen und Zerlegung:<span class="mywbr"> &nbsp;</span> Algebraische Datentypen</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="bsl-semantics.html" class="tocviewlink" data-pltdoc="x">Bedeutung von BSL</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="Daten_beliebiger_Gr__e.html" class="tocviewlink" data-pltdoc="x">Daten beliebiger Gr&#246;&#223;e</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="patternmatching.html" class="tocviewlink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Quote_und_Unquote.html" class="tocviewlink" data-pltdoc="x">Quote und Unquote</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="lang-support.html" class="tocviewlink" data-pltdoc="x">Sprachunterst&#252;tzung f&#252;r Datendefinitionen und Signaturen</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="lang-support-adts.html" class="tocviewlink" data-pltdoc="x">Sprachunterst&#252;tzung f&#252;r Algebraische Datentypen</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="DRY__Abstraktion__berall_.html" class="tocviewlink" data-pltdoc="x">DRY:<span class="mywbr"> &nbsp;</span> Abstraktion &#252;berall!</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="Programmieren_mit_Higher-Order_Funktionen.html" class="tocviewlink" data-pltdoc="x">Programmieren mit Higher-<wbr></wbr>Order Funktionen</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Bedeutung_von_ISL_.html" class="tocviewlink" data-pltdoc="x">Bedeutung von ISL+</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Generative Rekursion</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Akkumulation_von_Wissen.html" class="tocviewlink" data-pltdoc="x">Akkumulation von Wissen</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>17&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Generative Rekursion</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">17.1&nbsp;</td><td><a href="#%28part._.Wo_kollidiert_der_.Ball_%29" class="tocviewlink" data-pltdoc="x">Wo kollidiert der Ball?</a></td></tr><tr><td align="right">17.2&nbsp;</td><td><a href="#%28part._.Schnelles_.Sortieren%29" class="tocviewlink" data-pltdoc="x">Schnelles Sortieren</a></td></tr><tr><td align="right">17.3&nbsp;</td><td><a href="#%28part._entwurf-genrec%29" class="tocviewlink" data-pltdoc="x">Entwurf von generativ rekursiven Funktionen</a></td></tr><tr><td align="right">17.4&nbsp;</td><td><a href="#%28part._terminierung%29" class="tocviewlink" data-pltdoc="x">Terminierung</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">17.1<tt>&nbsp;</tt></span><a href="#%28part._.Wo_kollidiert_der_.Ball_%29" class="tocsubseclink" data-pltdoc="x">Wo kollidiert der Ball?</a></td></tr><tr><td><span class="tocsublinknumber">17.2<tt>&nbsp;</tt></span><a href="#%28part._.Schnelles_.Sortieren%29" class="tocsubseclink" data-pltdoc="x">Schnelles Sortieren</a></td></tr><tr><td><span class="tocsublinknumber">17.3<tt>&nbsp;</tt></span><a href="#%28part._entwurf-genrec%29" class="tocsubseclink" data-pltdoc="x">Entwurf von generativ rekursiven Funktionen</a></td></tr><tr><td><span class="tocsublinknumber">17.4<tt>&nbsp;</tt></span><a href="#%28part._terminierung%29" class="tocsubseclink" data-pltdoc="x">Terminierung</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Bedeutung_von_ISL_.html" title="backward to &quot;16 Bedeutung von ISL+&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Informatik 1, WS 2021/22 Universität Tübingen&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Akkumulation_von_Wissen.html" title="forward to &quot;18 Akkumulation von Wissen&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>17<tt>&nbsp;</tt><a name="(part._.Generative_.Rekursion)"></a>Generative Rekursion</h3><p>H&#228;ufig richtet sich die Struktur von Funktionen nach der Struktur der Daten, auf denen die Funktionen arbeiten.
Beispielsweise sieht unser Entwurfsrezept f&#252;r algebraische Datentypen vor, f&#252;r jede Alternative des Datentyps eine Hilfsfunktion
zu definieren. Wenn wir einen rekursiven Datentyp haben, so sieht unser Entwurfsrezept den Einsatz struktureller Rekursion vor.</p><p>In manchen F&#228;llen jedoch muss man von dieser Parallelit&#228;t von Daten und Funktionen abweichen: Die Struktur der Daten
passt nicht zu der Art und Weise, wie das Problem in Teilprobleme aufgeteilt werden soll.</p><h4>17.1<tt>&nbsp;</tt><a name="(part._.Wo_kollidiert_der_.Ball_)"></a>Wo kollidiert der Ball?</h4><p>Betrachten Sie als Beispiel die Fallstudie zum Ball in Bewegung in <a href="produkttypen.html#%28part._ballinbewegung%29" data-pltdoc="x">Fallstudie: Ein Ball in Bewegung</a>. Nehmen wir an, wir m&#246;chten eine
Funktion, die zu einem Ball berechnet, an welcher Position der Ball das erste Mal eine Kollision mit der Wand hat.
Wenn wir einen Ball <span class="RktSym">ball</span> haben, so k&#246;nnen wir durch Aufruf von <span class="RktPn">(</span><span class="RktSym">move-ball</span><span class="stt"> </span><span class="RktSym">ball</span><span class="RktPn">)</span>, <span class="RktPn">(</span><span class="RktSym">move-ball</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">move-ball</span><span class="stt"> </span><span class="RktSym">ball</span><span class="RktPn">)</span><span class="RktPn">)</span>
usw. die Bewegung des Balls simulieren. Wie lange wollen wir diese Simulation durchf&#252;hren? So lange, bis es eine Kolllision gibt,
also bis <span class="RktPn">(</span><span class="RktSym">collision</span><span class="stt"> </span><span class="RktSym">current-ball</span><span class="RktPn">)</span> nicht <span class="RktVal">"none"</span> ist.</p><p>Dies rechtfertigt die folgende Definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Ball -&gt; Posn</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">computes the position where the first collision of the ball occurs</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first-collision</span><span class="hspace">&nbsp;</span><span class="RktSym">ball</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._string~3d~3f%29%29" class="RktValLink" data-pltdoc="x">string=?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">collision</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ball-loc</span><span class="hspace">&nbsp;</span><span class="RktSym">ball</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"none"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first-collision</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">move-ball</span><span class="hspace">&nbsp;</span><span class="RktSym">ball</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ball-loc</span><span class="hspace">&nbsp;</span><span class="RktSym">ball</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Wenn wir uns diese Definition anschauen, so stellen wir zwei Besonderheiten fest: 1) Die Fallunterscheidung im Body der Funktion
hat nichts mit der Struktur der Eingabe zu tun. 2) Das Argument, welches wir im rekursiven Funktionsaufruf &#252;bergeben, ist kein
Teil der urspr&#252;nglichen Eingabe. Stattdessen generiert <span class="RktPn">(</span><span class="RktSym">move-ball</span><span class="stt"> </span><span class="RktSym">ball</span><span class="RktPn">)</span> einen v&#246;llig neuen Ball, n&#228;mlich den Ball der
um einen Schritt vorger&#252;ckt ist. Offensichtlich ist es nicht m&#246;glich, mit unserem bisherigen Entwurfsrezept eine Funktion dieser
Art zu generieren.</p><h4>17.2<tt>&nbsp;</tt><a name="(part._.Schnelles_.Sortieren)"></a>Schnelles Sortieren</h4><p>Betrachten Sie das Problem, eine Liste von Zahlen zu sortieren. Eine Verwendung unseres Entwurfsrezepts ergibt folgendes Template:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(listof number)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">(listof number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">to create a list of numbers with the same numbers as</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">l sorted in ascending order</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._sort%29%29" class="RktValLink" data-pltdoc="x">sort</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpabstraction.html#%28form._x._%28%28lib._teachpack%2F2htdp%2Fabstraction..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._sort%29%29" class="RktValLink" data-pltdoc="x">sort</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Im Basisfall ist die Vervollst&#228;ndigung des Templates trivial. Im rekursiven Fall m&#252;ssen wir offensichtlich <span class="RktSym">x</span> in die
bereits sortierte Liste <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._sort%29%29" class="RktValLink" data-pltdoc="x">sort</a></span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> einf&#252;gen. Hierzu k&#246;nne wir die bereits in
<a href="DRY__Abstraktion__berall_.html#%28part._funktionsparameter%29" data-pltdoc="x">Funktionen als Funktionsparameter</a> definierte Funktion <span class="RktSym">insert</span> verwenden. Insgesamt ergibt sich damit die folgende Definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(listof number)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">(listof number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">to create a list of numbers with the same numbers as</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">l sorted in ascending order</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._sort%29%29" class="RktValLink" data-pltdoc="x">sort</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpabstraction.html#%28form._x._%28%28lib._teachpack%2F2htdp%2Fabstraction..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._sort%29%29" class="RktValLink" data-pltdoc="x">sort</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Dieser Algorithmus, den man auch <span style="font-style: italic">insertion sort</span> nennt, ergibt sich zwangsl&#228;ufig, wenn man mittels struktureller Rekursion
eine Liste sortieren m&#246;chte. Allerdings ist dieser Algorithmus nicht sehr effizient. Wenn wir eine Liste <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktSym">x-1</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="stt"> </span><span class="RktSym">x-n</span><span class="RktPn">)</span>
haben, so ergibt die Expansion von <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._sort%29%29" class="RktValLink" data-pltdoc="x">sort</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktSym">x-1</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="stt"> </span><span class="RktSym">x-n</span><span class="RktPn">)</span><span class="RktPn">)</span> den Ausdruck <span class="RktPn">(</span><span class="RktSym">insert</span><span class="stt"> </span><span class="RktSym">x-1</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="stt"> </span><span class="RktSym">x-2</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="stt"> </span><span class="RktSym">x-n</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span>.
Im schlechtesten Fall (beispielsweise einer r&#252;ckw&#228;rts sortierten Liste) ben&#246;tigt <span class="RktSym">insert</span> so viele Berechungsschritte, wie die Liste lang ist.
Da n + (n-1) + ... + 1 = n*(n+1)/2, ergibt sich, dass die Anzahl der Berechnungsschritte des Sortieralgorithmus im schlechtesten Fall
quadratisch mit der L&#228;nge der Eingabe w&#228;chst.</p><p>Ein besserer Algorithmus ergibt sich, wenn wir das Problem geschickter in Teilprobleme zerlegen, als die Struktur der Daten dies suggeriert.
Ein g&#228;ngiger Algorithmus ist <span style="font-style: italic">quick sort</span>. Bei diesem Algorithmus w&#228;hlen wir in jedem Schritt ein Element aus, beispielsweise das erste
Listenelement. Dieses Element wird Pivot-Element genannt. Dann unterteilen wir den Rest der Liste in Listenelemente die kleiner (oder gleich)
und solche die gr&#246;&#223;er als das Pivot-Element sind. Wenn wir diese neu generierten Listen rekursiv sortieren, so k&#246;nnen wir die Gesamtliste sortieren,
indem wir die beiden sortierten Listen mit dem Pivot-Element in der Mitte aneinanderh&#228;ngen.</p><p>Insgesamt ergibt sich damit folgende Definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(listof number)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">(listof number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">to create a list of numbers with the same numbers as</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">l sorted in ascending order</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">qsort</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpabstraction.html#%28form._x._%28%28lib._teachpack%2F2htdp%2Fabstraction..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._append%29%29" class="RktValLink" data-pltdoc="x">append</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">qsort</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">qsort</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">greater-than</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Number (listof Number) -&gt; (listof Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">computes a list of all elements of xs that are</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">smaller or equal than x</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._filter%29%29" class="RktValLink" data-pltdoc="x">filter</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._~3c~3d%29%29" class="RktValLink" data-pltdoc="x">&lt;=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Number (listof Number) -&gt; (listof Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">computes a list of all elements of xs that are</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">greater than x</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">greater-than</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._filter%29%29" class="RktValLink" data-pltdoc="x">filter</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._~3e%29%29" class="RktValLink" data-pltdoc="x">&gt;</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Die Rekursionsstruktur in diesem Algorithmus unterscheidet sich ebenfalls deutlich von dem bekannten Muster der strukturellen Rekursion.
Die Eingabe des rekursiven Aufrufs ist zwar in gewissem Sinne ein Teil der Eingabe (in dem Sinne dass die Listenelemente in den rekursiven Aufrufen
eine Teilmenge der Listenelemente der Originaleingabe bilden), aber sie sind kein Teil der Eingabe im Sinne der Struktur der Eingabe.
Die Fallunterscheidung in diesem Beispiel ist die gleiche, die wir auch bei struktureller Rekursion haben, aber statt einem rekursiven
Aufruf wie bei struktureller Rekursion auf Listen haben wir zwei rekursive Aufrufe.</p><p>Es ist nicht ganz einfach, zu sehen, dass quick sort in der Regel viel schneller ist als insertion sort (und auch nicht Thema dieser
Lehrveranstaltung), aber Sie k&#246;nnen sehen, dass f&#252;r den Fall, dass die beiden Listen <span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> und
<span class="RktPn">(</span><span class="RktSym">greater-than</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> stets etwa gleich gro&#223;e Listen erzeugen, die Rekursionstiefe nur logarithmisch in der L&#228;nge der Liste ist.
Man kann zeigen, dass die Anzahl der ben&#246;tigten Rechenschritte zur Sortierung einer Liste der L&#228;nge n im Durchschnitt proportional zu
n*log(n) ist.</p><h4>17.3<tt>&nbsp;</tt><a name="(part._entwurf-genrec)"></a>Entwurf von generativ rekursiven Funktionen</h4><p>Wir nennen Rekursionsstrukturen die nicht (notwendigerweise) dem Muster der strukturellen Rekursion entsprechen <span style="font-style: italic">generative Rekursion</span>.
Eine generativ rekursive Rekursion hat eine Struktur, die etwa wie folgt aussieht:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generative-recursive-fun</span><span class="hspace">&nbsp;</span><span class="RktSym">problem</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">trivially-solvable?</span><span class="hspace">&nbsp;</span><span class="RktSym">problem</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">determine-solution</span><span class="hspace">&nbsp;</span><span class="RktSym">problem</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">combine-solutions</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktSym">problem</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generative-recursive-fun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-problem-1</span><span class="hspace">&nbsp;</span><span class="RktSym">problem</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generative-recursive-fun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-problem-n</span><span class="hspace">&nbsp;</span><span class="RktSym">problem</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Dieses Template soll verdeutlichen, dass wir &#252;ber beim Entwurf einer generativ rekursiven Funktion die folgenden
f&#252;nf Fragen beantworten m&#252;ssen:</p><ol><li><p>Was ist ein trivial l&#246;sbares Problem?</p></li><li><p>Was ist die L&#246;sung f&#252;r ein trivial l&#246;sbares Problem?</p></li><li><p>Wie generieren wir neue Probleme, die leichter l&#246;sbar sind als das Originalproblem? Wie viele neue Probleme
sollen wir generieren?</p></li><li><p>Wie berechnen wir aus den L&#246;sungen der generierten Probleme die L&#246;sung des Originalproblems? Ben&#246;tigen wir
hierzu nochmal das Originalproblem (oder einen Teil davon)?</p></li><li><p>Wieso terminiert der Algorithmus?</p></li></ol><p>Die letzte Frage werden wir in n&#228;chsten Abschnitt separat behandeln. Die Antwort auf die ersten vier Fragen
f&#252;r das erste Beispiel oben lautet: 1) Ein Ball der bereits kollidiert. 2) Die aktuelle Position des Balles. 3) Indem wir einen
Bewegungsschritt des Balles vornehmen (und ihn damit n&#228;her zur Kollisionsstelle bringen). 4) Die L&#246;sung des generierten
Problems ist die L&#246;sung des Originalproblems; keine weitere Berechnung ist n&#246;tig.</p><p>Die Antwort auf die ersten vier Fragen f&#252;r das zweite Beispiel lautet: 1) Das Sortieren einer leeren Liste. 2) Die leere Liste.
3) Indem wir ein Pivotelement ausw&#228;hlen und zwei neue Probleme generieren: Das Sortieren der Liste aller Elemente des Originalproblems,
die kleiner (oder gleich) als das Pivotelement sind, und das Sortieren der Liste aller Elemente des Originalproblems,
die gr&#246;&#223;er als das Pivotelement sind. 4) Indem wir die beiden sortierten Listen mit dem Pivotelement in der Mitte zusammenh&#228;ngen.</p><p>Eine generativ rekursive Funktion sollte in folgenden Situationen erwogen werden: 1) Die Eingabe hat eine rekursive Struktur, aber
es ist nicht m&#246;glich oder zu kompliziert, mittels struktureller Rekursion das Problem zu l&#246;sen (beispielsweise weil das Ergebnis des
rekursiven Aufrufs nicht hilft, das Originalproblem zu l&#246;sen). 2) Es gibt eine strukturell rekursive Funktion, die das Problem l&#246;st,
aber sie ist nicht effizient genug. 3) Die Eingabe ist nicht rekursiv, aber die Anzahl der Berechnungsschritte zur L&#246;sung des
Problems ist nicht proportional zur Gr&#246;&#223;e der Eingabe.</p><p>Wenn Sie ein Problem mittels generativer Rekursion l&#246;sen m&#246;chten, sollten Sie als erstes die vier Fragen oben beantworten und dann
im Template-Schritt des Entwurfsrezepts das oben stehende Template verwenden (angepasst auf die Antworten auf Frage 1 und 3).
Mit den Antworten auf die Frage 2 und 4 k&#246;nnen Sie dann die Implementierung des Templates vervollst&#228;ndigen. Die Tests f&#252;r die
Funktion sollten auf jeden Fall sowohl Beispiele f&#252;r triviale Probleme als auch f&#252;r den generativ rekursiven Fall enthalten.</p><p>Ein wichtiger Unterschied zwischen struktureller Rekursion und generativer Rekursion ist, dass der Entwurf generativ rekursiver
Funktionen mehr Kreativit&#228;t erfordert. Inbesondere ist eine besondere gedankliche Einsicht erforderlich, wie aus dem
Problem sinnvolle kleinere Teilprobleme generiert werden k&#246;nnen. Bei struktureller Rekursion hingegen ergibt sich die Funktionsdefinition
oft schon fast zwingend aus dem Template.</p><h4>17.4<tt>&nbsp;</tt><a name="(part._terminierung)"></a>Terminierung</h4><p>Eine wichtige Eigenschaft von strukturell rekursiven Funktionen ist, dass diese immer terminieren: Da die Eingabedaten eine endliche Gr&#246;&#223;e
haben und in jedem rekursiven Aufruf die Eingabe echt kleiner wird, muss irgendwann ein nichtrekursiver Basisfall erreicht werden.</p><p>Dies ist bei generativer Rekursion anders: Wir m&#252;ssen explizit &#252;berlegen, warum eine generativ rekursive Funktion terminiert.</p><p>Betrachten Sie hierzu eine Variante des <span class="RktSym">qsort</span> Algorithmus von oben, in dem wir den Ausdruck
<span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> ersetzen durch <span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">l</span><span class="RktPn">)</span>. Statt also nur aus der Restliste
(ohne Pivotelement) die kleiner-oder-gleichen Elemente herauszusuchen, suchen wir in der Liste, die auch
das Pivotelement noch enth&#228;lt:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28form._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">qsort</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/teachpack/2htdpabstraction.html#%28form._x._%28%28lib._teachpack%2F2htdp%2Fabstraction..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._append%29%29" class="RktValLink" data-pltdoc="x">append</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">qsort</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">qsort</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">greater-than</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Betrachten wir nun einen Aufruf wie <span class="RktPn">(</span><span class="RktSym">qsort</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span>. Da <span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="stt"> </span><span class="RktVal">5</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span> die Liste <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">5</span><span class="RktPn">)</span>
ergibt, wird dieser Aufruf zu einem rekursiven Aufruf der Form <span class="RktPn">(</span><span class="RktSym">qsort</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span> f&#252;hren. Wir haben also eine Endlosschleife produziert.</p><p><div class="SIntrapara">Wie k&#246;nnen wir diesen Fehler vermeiden? Die Terminierung einer generativ rekursiven Funktion kann durch zwei Schritte gezeigt werden:
</div><div class="SIntrapara"><ol><li><p>Wir definieren eine Abbildung, die den Satz von Funktionsargumenten auf eine nat&#252;rliche Zahl abbildet. Diese Abbildung
misst quasi die Gr&#246;&#223;e der Eingabe, wobei "Gr&#246;&#223;e" nicht notwendigerweise die physikalische Gr&#246;&#223;e der Daten im Speicher
beschreibt sondern die Gr&#246;&#223;e des Problems aus Sicht des Algorithmus.</p></li><li><p>Wir zeigen, dass die Gr&#246;&#223;e der Eingabe bzgl. der Abbildung aus dem ersten Schritt in allen rekursiven Funktionsaufrufen
strikt kleiner wird.</p></li></ol></div><div class="SIntrapara">Falls die Gr&#246;&#223;e der Originaleingabe (bzgl. der definierten Abbildung) also n ist, so ist sichergestellt, dass die maximale Rekursionstiefe ebenfalls n ist.</div></p><p>Im Falle von quick sort k&#246;nnen wir als Abbildung im ersten Schritt die L&#228;nge der Liste <span class="RktSym">l</span> verwenden. Falls die L&#228;nge
von <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> n ist, so ist die L&#228;nge von <span class="RktSym">xs</span> n-1 und damit sind auch <span class="RktPn">(</span><span class="RktSym">smaller-or-equal-than</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span>
und <span class="RktPn">(</span><span class="RktSym">greater-than</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> nicht gr&#246;&#223;er als n-1. Daher wird die Gr&#246;&#223;e der Eingabe in allen rekursiven Aufrufen strikt kleiner.</p><p>Im Falle von <span class="RktSym">first-collision</span> ist es deutlich komplizierter, die Terminierung zu zeigen. &#220;berlegen Sie, wie in diesem
Fall die Gr&#246;&#223;e der Eingabe gemessen werden kann, so dass die Bedingung aus dem zweiten Schritt gilt.
Hinweis: Tats&#228;chlich terminiert <span class="RktSym">first-collision</span> nicht immer. Verwenden Sie die Suche nach einem Terminierungsbeweis
dazu, um diesen Fehler zu finden und zu beheben.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Bedeutung_von_ISL_.html" title="backward to &quot;16 Bedeutung von ISL+&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Informatik 1, WS 2021/22 Universität Tübingen&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Akkumulation_von_Wissen.html" title="forward to &quot;18 Akkumulation von Wissen&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>