<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>12&nbsp;Sprachunterstützung für Datendefinitionen und Signaturen</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Informatik 1, WS 2023/<span class="mywbr"> &nbsp;</span>24 Universit&#228;t T&#252;bingen</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Programmieren_mit_Ausdr_cken.html" class="tocviewlink" data-pltdoc="x">Programmieren mit Ausdr&#252;cken</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Programmierer_entwerfen_Sprachen_.html" class="tocviewlink" data-pltdoc="x">Programmierer entwerfen Sprachen!</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Systematischer_Programmentwurf.html" class="tocviewlink" data-pltdoc="x">Systematischer Programmentwurf</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Batchprogramme_und_interaktive_Programme.html" class="tocviewlink" data-pltdoc="x">Batchprogramme und interaktive Programme</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="summentypen.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Alternativen:<span class="mywbr"> &nbsp;</span> Summentypen</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="produkttypen.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Zerlegung:<span class="mywbr"> &nbsp;</span> Produkttypen</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="adts.html" class="tocviewlink" data-pltdoc="x">Datendefinition durch Alternativen und Zerlegung:<span class="mywbr"> &nbsp;</span> Algebraische Datentypen</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="bsl-semantics.html" class="tocviewlink" data-pltdoc="x">Bedeutung von BSL</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="Daten_beliebiger_Gr__e.html" class="tocviewlink" data-pltdoc="x">Daten beliebiger Gr&#246;&#223;e</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="patternmatching.html" class="tocviewlink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Quote_und_Unquote.html" class="tocviewlink" data-pltdoc="x">Quote und Unquote</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Sprachunterst&#252;tzung f&#252;r Datendefinitionen und Signaturen</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="lang-support-adts.html" class="tocviewlink" data-pltdoc="x">Sprachunterst&#252;tzung f&#252;r Algebraische Datentypen</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="DRY__Abstraktion__berall_.html" class="tocviewlink" data-pltdoc="x">DRY:<span class="mywbr"> &nbsp;</span> Abstraktion &#252;berall!</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="Programmieren_mit_Higher-Order_Funktionen.html" class="tocviewlink" data-pltdoc="x">Programmieren mit Higher-<wbr></wbr>Order Funktionen</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Bedeutung_von_ISL_.html" class="tocviewlink" data-pltdoc="x">Bedeutung von ISL+</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Generative_Rekursion.html" class="tocviewlink" data-pltdoc="x">Generative Rekursion</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Akkumulation_von_Wissen.html" class="tocviewlink" data-pltdoc="x">Akkumulation von Wissen</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>12&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Sprachunterst&#252;tzung f&#252;r Datendefinitionen und Signaturen</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">12.1&nbsp;</td><td><a href="#%28part._.Ungetypte_.Sprachen%29" class="tocviewlink" data-pltdoc="x">Ungetypte Sprachen</a></td></tr><tr><td align="right">12.2&nbsp;</td><td><a href="#%28part._.Dynamisch_getypte_.Sprachen%29" class="tocviewlink" data-pltdoc="x">Dynamisch getypte Sprachen</a></td></tr><tr><td align="right">12.3&nbsp;</td><td><a href="#%28part._contracts%29" class="tocviewlink" data-pltdoc="x">Dynamisch &#252;berpr&#252;fte Signaturen und Contracts</a></td></tr><tr><td align="right">12.4&nbsp;</td><td><a href="#%28part._.Statisch_getypte_.Sprachen%29" class="tocviewlink" data-pltdoc="x">Statisch getypte Sprachen</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">12.1<tt>&nbsp;</tt></span><a href="#%28part._.Ungetypte_.Sprachen%29" class="tocsubseclink" data-pltdoc="x">Ungetypte Sprachen</a></td></tr><tr><td><span class="tocsublinknumber">12.2<tt>&nbsp;</tt></span><a href="#%28part._.Dynamisch_getypte_.Sprachen%29" class="tocsubseclink" data-pltdoc="x">Dynamisch getypte Sprachen</a></td></tr><tr><td><span class="tocsublinknumber">12.3<tt>&nbsp;</tt></span><a href="#%28part._contracts%29" class="tocsubseclink" data-pltdoc="x">Dynamisch &#252;berpr&#252;fte Signaturen und Contracts</a></td></tr><tr><td><span class="tocsublinknumber">12.4<tt>&nbsp;</tt></span><a href="#%28part._.Statisch_getypte_.Sprachen%29" class="tocsubseclink" data-pltdoc="x">Statisch getypte Sprachen</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Quote_und_Unquote.html" title="backward to &quot;11 Quote und Unquote&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Informatik 1, WS 2023/24 Universität Tübingen&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lang-support-adts.html" title="forward to &quot;13 Sprachunterstützung für Algebraische Datentypen&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><h3>12<tt>&nbsp;</tt><a name="(part._lang-support)"></a>Sprachunterst&#252;tzung f&#252;r Datendefinitionen und Signaturen</h3><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Dies gilt zumindest f&#252;r alle sogenannten "Turing-vollst&#228;ndigen" Sprachen. Fast
alle g&#228;ngigen Programmiersprachen sind Turing-vollst&#228;ndig.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">In einem gewissen Sinne ist es egal, welche Programmiersprache man verwendet: Jede Berechnung und
jeder Algorithmus lassen sich in jeder Programmiersprache ausdr&#252;cken. Man kann jede Programmiersprache
und jedes Programmiersprachenkonzept in jeder anderen Programmiersprache simulieren.</div></p><p>Die Entwurfstechniken, die wir Ihnen beibringen, lassen sich in allen Programmiersprachen verwenden.
Allerdings unterscheiden sich Programmiersprachen darin, wie gut die Entwurfstechniken durch die
Sprache unterst&#252;tzt werden. Wenn Sie beispielsweise in Assembler-Programmiersprachen programmieren,
gibt es nichts,
was unserem <span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span> entspricht; ein Assembler Programmierer muss sich daher selber &#252;berlegen,
wie er mehrere Werte zusammenfasst und in einem linearen Speicher anordnet.</p><p>Auf der anderen Seite gibt es auch Programmiersprachen, in denen unsere Entwurfstechniken besser
unterst&#252;tzt werden als in BSL.</p><p>In diesem Kapitel wollen wir dar&#252;ber reden, wie Sprachen eines unserer Kernkonzepte unterst&#252;tzen
k&#246;nnen, n&#228;mlich das der Datendefinitionen und Signaturen. Datendefinitionen dienen zur Strukturierung
und Klassifikation der Daten in unserem Programm. Signaturen dienen der Beschreibung der Erwartungen
einer Funktion an ihre Argumente und der Beschreibung der Garantien bez&#252;glich des Ergebnisses.</p><p>Um Sprachen und Sprachfeatures bez&#252;glich ihrer Unterst&#252;tzung f&#252;r Datendefinitionen und Signaturen
zu bewerten, ben&#246;tigen wir Kriterien, die qualitativ diese Unterst&#252;tzung messen. Wir wollen die
folgenden Kriterien betrachten:</p><ul><li><p>Ist sichergestellt, dass alle Werte und Funktionen in einer Weise verwendet werden, die
zur Information/Berechnung, die dieser Wert/Funktion repr&#228;sentiert, passt?</p></li><li><p>Zu welchem Zeitpunkt werden Fehler gefunden? Im Allgemeinen m&#246;chte man, dass Fehler
m&#246;glichst fr&#252;h auftreten; am besten schon bevor das Programm startet, aber zumindest zu
dem Zeitpunkt, zu dem der Programmteil, der f&#252;r den Fehler verantwortlich ist, ausgef&#252;hrt wird.
Am schlechtesten ist, wenn das Programm selber niemals einen Fehler meldet und stattdessen
m&#246;glicherweise unbemerkt falsche Ergebnisse produziert.</p></li><li><p>Wie modular sind die Fehlermeldungen? Wenn ein Fehler auftritt, so m&#246;chte man wissen, welcher
Programmteil daran "schuld" ist. Dieses sogenannte "Blame Assignment" ist &#228;u&#223;erst wichtig, um
Fehler effektiv lokalisieren und beheben zu k&#246;nnen. Bei Fehlern sollte es stets einen klar
benennbaren Programmteil geben, der der Verursacher dieses Fehlers war.</p></li><li><p>Wie ausdrucksstark ist die Signatursprache? Kann man die Bedingungen an Eingaben und
Ausgaben pr&#228;zise darin ausdr&#252;cken?</p></li><li><p>Gibt es sinnvolle Programme, die nicht mehr ausgef&#252;hrt werden k&#246;nnen? </p></li><li><p>Wird die Aufrechterhaltung der Konsistenz zwischen Datendefinitionen/Signaturen
und dem Programmverhalten unterst&#252;tzt?</p></li></ul><p>Im folgenden wollen wir die wichtigsten Klassen von Programmiersprachen beschreiben, die sich
in wichtigen Punkten bez&#252;glich der oben angef&#252;hrten Kriterien unterscheiden.</p><h4>12.1<tt>&nbsp;</tt><a name="(part._.Ungetypte_.Sprachen)"></a>Ungetypte Sprachen</h4><p>Ungetypte Sprachen zeichnen sich dadurch aus, dass jede Operation auf alle Arten von Daten
angewendet werden kann, unabh&#228;ngig davon ob es einen Sinn ergibt oder nicht. Beispielsweise
ist es nicht sinnvoll, einen String und eine Zahl miteinander zu addieren.</p><p>Assembler-Sprachen sind typischerweise ungetypt. Alle Arten von Daten werden als (32 oder 64 bit) Zahlen
repr&#228;sentiert. Auch Strings, boolsche Werte, und alle anderen Daten werden durch solche
Zahlenwerte repr&#228;sentiert. Addiert man nun zwei Werte, so werden die Zahlenwerte addiert, egal
ob das aus Sicht dessen, was diese Werte repr&#228;sentieren, einen Sinn ergibt.</p><p>Bez&#252;glich des ersten Punkts aus der Liste oben bieten ungetypte Sprachen daher keinerlei
Unterst&#252;tzung; es liegt vollst&#228;ndig in der Verantwortung des Programmierers, diese Eigenschaft
sicherzustellen.</p><p>Fehler, also Verst&#246;&#223;e gegen diese Eigenschaft, werden in Assembler-Programmen dementsprechend
sehr sp&#228;t gefunden, denn das Programm l&#228;uft ja einfach immer weiter, auch wenn die Daten, die
gerade berechnet wurden, v&#246;llig unsinnig sind.</p><p>Da es keine von der Sprache unterst&#252;tzten Signaturen oder Datendefinitionen gibt, gibt es auch
keine Einschr&#228;nkungen bez&#252;glich der Ausdrucksst&#228;rke der Signaturen/Datendefinitionen und es
gibt keine Einschr&#228;nkungen der Art, dass bestimmte Programme nicht ausgef&#252;hrt werden k&#246;nnen.
Allerdings gibt es auch keinerlei Unterst&#252;tzung f&#252;r die Aufrechterhaltung der Konsistenz; dies
liegt allein in der Verantwortlichkeit des Programmierers.</p><h4>12.2<tt>&nbsp;</tt><a name="(part._.Dynamisch_getypte_.Sprachen)"></a>Dynamisch getypte Sprachen</h4><p>In dynamisch getypten Sprachen wird jedem Wert ein Typ zugeordnet und das Laufzeitsystem repr&#228;sentiert
Werte so, dass der Typ eines Wertes w&#228;hrend der Ausf&#252;hrung jederzeit abgefragt werden kann.
Ein Typ ist daher eine Art Markierung f&#252;r Werte, die dar&#252;ber Auskunft gibt, was f&#252;r eine Art von
Wert es ist. Typischerweise gibt es (je nach Sprache unterschiedliche) fest eingebaute ("primitive")
Typen sowie vom Benutzer zu definierende Typen. Die Beginning Student Language, in der wir
bisher programmiert haben, ist eine dynamisch getypte Sprache. Fest eingebaute Typen sind beispielsweise
Boolean (<span class="RktSym"><a href="http://docs.racket-lang.org/reference/booleans.html#%28def._%28%28quote._~23~25kernel%29._boolean~3f%29%29" class="RktValLink" data-pltdoc="x">boolean?</a></span>), Number (<span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span>), String (<span class="RktSym"><a href="http://docs.racket-lang.org/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span>) und Symbole (<span class="RktSym"><a href="http://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span>).
Neue Typen k&#246;nnen mittels <span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span> definiert werden.</p><p>Die dynamischen Typen werden verwendet, um sicherzustellen, dass nur solche primitiven Operationen
auf Werte angewendet werden, die auch f&#252;r diese Werte definiert sind. Wenn wir beispielsweise
<span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span> auswerten, so pr&#252;ft das Laufzeitsystem, dass <span class="RktSym">x</span> und <span class="RktSym">y</span>
auch tats&#228;chlich Zahlen sind. Wenn <span class="RktSym">x</span> hingegen beispielsweise ein boolscher Wert ist, so
wird dieser, anders als bei ungetypten Sprachen, nicht einfach irgendwie als Zahl interpretiert.</p><p>Allerdings gilt diese Eigenschaft nicht f&#252;r vom Programmierer selber definierte Funktionen.
Es ist &#228;u&#223;erst sinnvoll, jede Funktionsdefinition mit einer Signatur zu versehen, so wie wir es
ja auch gemacht haben, doch es wird nicht gepr&#252;ft, ob die Signatur auch von der Funktion und den
Aufrufern der Funktion eingehalten wird.</p><p>Da die dynamischen Typen jedoch nicht alle Informationen umfassen, die wir in Datendefinitionen
festhalten, kann es dennoch zu Fehlbenutzungen von Werten kommen. Beispielsweise macht es keinen
Sinn, eine Temperatur und eine L&#228;nge zu addieren. Falls beide jedoch durch den Typ Number repr&#228;sentiert
werden, kann das Laufzeitsystem diesen Fehler nicht feststellen.</p><p>Schauen wir uns mal an einigen Beispielen an, wie und wann in dynamischen Typsystemen Typfehler auftauchen.
Betrachten Sie folgende Funktion:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Number (list-of Number) -&gt; (list-of Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">returns the remainder of xs after first occurence of x, or empty otherwise</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Die Funktion gibt den Rest der Liste nach dem ersten Vorkommen des Elements <span class="RktSym">x</span> zur&#252;ck (und <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span>
falls das Element nicht vorkommt). Hier zwei Beispiele dazu:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">()</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(3 4)</span></p></td></tr></table></blockquote><p>Was passiert jedoch, wenn wir die Signatur verletzten?</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"eins"</span><span class="hspace">&nbsp;</span><span class="RktVal">"zwei"</span><span class="hspace">&nbsp;</span><span class="RktVal">"drei"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">=: expects a number, given "eins"</span></p></td></tr></table></blockquote><p>Wir sehen, dass wir in diesem Fall einen Laufzeitfehler erhalten.  Allerdings tritt nicht bei jeder
Verletzung der Signatur (sofort) ein Laufzeitfehler auf:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">"drei"</span><span class="hspace">&nbsp;</span><span class="RktVal">"vier"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">("drei" "vier")</span></p></td></tr></table></blockquote><p>In diesem Beispiel wird eine Liste &#252;bergeben, die nicht nur Zahlen enth&#228;lt, aber da die hinteren
Elemente der Liste nicht verwendet werden gibt es auch keinen Laufzeitfehler.</p><p>Betrachten wir jetzt einmal den Fall, dass nicht der Aufrufer der Funktion sondern die Funktion selber
die Signatur verletzt. In diesem Beispiel gibt die Funktion einen String statt einer leeren Liste
zur&#252;ck, falls <span class="RktSym">x</span> in der Liste nicht vorkommt.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Number (list-of Number) -&gt; (list-of Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">returns the remainder of xs after first occurence of x, or empty otherwise</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"not a list"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">Diese Beispiele illustrieren, dass es keinen Fehler ergibt, wenn wir die Funktion mit einem <span class="RktSym">x</span>
aufrufen, welches in der Liste enthalten ist.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(3 4)</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Selbst wenn wir ein <span class="RktSym">x</span> ausw&#228;hlen, welches nicht in der Liste enthalten ist, ergibt die Ausf&#252;hrung
keinen Laufzeitfehler.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"not a list"</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Erst wenn wir das Ergebnis verwenden und damit rechnen kommt es zu einem Laufzeitfehler.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">cons: second argument must be a list, but received 6 and "not a list"</span></p></td></tr></table></blockquote></div></p><p>Allerdings ist es im Allgemeinen sehr schwer, herauszufinden, wer denn "Schuld" an diesem Fehler hat, denn
die Stelle an der der Fehler auftritt ist m&#246;glicherweise weit von der Stelle entfernt, die den Fehler verursacht.
Wenn Sie sich die Fehlermeldung anschauen, sehen Sie auch nichts, das darauf hindeutet, dass die Ursache
des Fehlers in der Implementierung der <span class="RktSym">rest-after</span> Funktion zu finden ist. Daher sind Fehlermeldungen
in dynamisch getypten Sprachen nicht sehr modular.</p><h4>12.3<tt>&nbsp;</tt><a name="(part._contracts)"></a>Dynamisch &#252;berpr&#252;fte Signaturen und Contracts</h4><p>Um Fehler fr&#252;her zu finden und Fehlermeldungen modularer zu machen, k&#246;nnen Signaturen und
Datendefinitionen auch als Programme definiert werden. Diese Programme k&#246;nnen dann
verwendet werden, um Signaturen zu &#252;berpr&#252;fen w&#228;hrend das Programm l&#228;uft.</p><p>Eine Datendefinition wie:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">a list-of-numbers is either:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt"> - empty</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt"> - (cons Number list-of numbers)</span></td></tr></table></blockquote><p>kann beispielsweise durch folgendes Programm repr&#228;sentiert werden:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">[X] (list-of X) -&gt; Boolean</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">checks whether xs contains only numbers</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list-of-numbers?</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#true</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list-of-numbers?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Diese "ausf&#252;hrbaren" Datendefinitionen k&#246;nnen dann, zusammen mit den
vordefinierten Pr&#228;dikaten wie <span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span> verwendet werden, um
eine dynamisch gepr&#252;fte Variante der <span class="RktSym">rest-after</span> Funktion
zu definieren:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Number (list-of Number) -&gt; (list-of Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">dynamically checked version of rest-after</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after/checked</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list~3f%29%29" class="RktValLink" data-pltdoc="x">list?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list-of-numbers?</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list-of-numbers?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"function must return list-of-numbers"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"second arg must be list-of-numbers"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"first arg must be a number"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Diese Funktion verh&#228;lt sich genau wie <span class="RktSym">rest-after</span> sofern
sich die Funktion und ihre Aufrufer an die Signatur halten:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after/checked</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(3 4)</span></p></td></tr></table></blockquote><p>Im Fehlerfall gibt es jedoch viel fr&#252;her eine Fehlermeldung und diese
Fehlermeldung ist modular (sie tritt an der Stelle auf, die auch
die Ursache des Fehlers ist).</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after/checked</span><span class="hspace">&nbsp;</span><span class="RktVal">"x"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">first arg must be a number</span></p></td></tr></table></blockquote><p>Allerdings werden nun auch Programme mit einer Fehlermeldung abgebrochen, die,
wie wir oben gesehen haben, vorher ohne Fehler durchgelaufen sind:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after/checked</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">"drei"</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">second arg must be list-of-numbers</span></p></td></tr></table></blockquote><p>Dennoch ist es sinnvoll, diese Programme mit einem Fehler abzubrechen, denn
im Allgemeinen wird fr&#252;her oder sp&#228;ter doch noch ein (dann nicht mehr
modularer) Fehler auftreten. In jedem Fall ist ein Verstoss gegen die
Signatur ein Hinweis auf einen Programmierfehler, unabh&#228;ngig davon ob
er tats&#228;chlich letzten Endes zu einem Fehler f&#252;hren w&#252;rde.</p><p>Wie wir sehen, ist es allerdings aus Programmierersicht relativ m&#252;hselig und
fehleranf&#228;llig, auf diese Art Signaturen und Datendefinitionen zu &#252;berpr&#252;fen.
Deshalb gibt es einige Sprachen, die die dynamische Pr&#252;fung von Signaturen
und Datendefinitionen direkt und komfortabel unterst&#252;tzen.</p><p>Wir haben bereits die M&#246;glichkeit kennengelernt, mit der <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._~3a%29%29" class="RktStxLink" data-pltdoc="x">:</a></span><span class="stt"> </span><span class="RktSym">name</span><span class="stt"> </span><span class="RktSym">signature-form</span><span class="RktPn">)</span>
Notation Signaturen dynamisch zu &#252;berpr&#252;fen. Diese Notation baut auf einem
allgemeineren, m&#228;chtigem Konzept auf, n&#228;mlich dem der <span style="font-style: italic">Contracts</span>. Diese
wollen wir hier kurz vorstellen.</p><p>Contracts werden an der Grenze zwischen Modulen definiert werden. Module sind abgeschlossene
Programmeinheiten, die in Racket meistens mit Dateien assoziiert sind, also jede
Datei ist ein Modul.</p><p>Hier sehen Sie die Definition eines Moduls welches die <span class="RktSym">rest-after</span> Funktion
von oben implementiert. In der <span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._provide%29%29" class="RktStxLink" data-pltdoc="x">provide</a></span> Klausel des Moduls wird dieser
Funktion ein <span style="font-style: italic">Contract</span>, also eine ausf&#252;hrbare Signatur, zugeordnet.
Wir speichern das Modul in einer Datei "Joe.rkt", um zu illustrieren, dass vielleicht
der Entwickler Joe dieses Modul programmiert hat. Wie Sie sehen, hat Joe
den gleichen Fehler in die Implementierung eingebaut, den wir schon oben betrachtet haben.</p><blockquote class="SCodeFlow"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="stt">"Joe.rkt"</span></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._provide%29%29" class="RktStxLink" data-pltdoc="x">provide</a></span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contract-out</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types-extra..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"not a list"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote><p>Betrachten Sie nun ein Modul vom Entwickler Elke, welche diese Funktion benutzen m&#246;chte und
daher das Modul von Joe &#252;ber eine <span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span> Klausel "importiert". &#220;ber diese Klausel
wird deutlich gemacht, dass das Modul von Elke von dem Joe Modul abh&#228;ngt und dessen
Funktionen verwenden m&#246;chte.</p><blockquote class="SCodeFlow"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="stt">"elke.rkt"</span></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"Joe.rkt"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">"x"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote><p>Elke hat allerdings im Aufruf der Funktion gegen den Contract verstossen und hat
als erstes Argument einen String &#252;bergeben. Wenn wir versuchen, dieses Programm
auszuf&#252;hren, so erhalten wir folgende Fehlermeldung:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rest-after: contract violation</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">expected: number?</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">given: "x"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">in: the 1st argument of</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">number?</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(listof number?)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(listof number?))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">contract from: /Users/klaus/Joe.rkt</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">blaming: /Users/klaus/elke.rkt</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(assuming the contract is correct)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">at: /Users/klaus/Joe.rkt:3.24</span></p></td></tr></table></p><p>Sie sehen, dass nicht nur der Aufruf der Funktion direkt als fehlerhaft erkannt wurde. Die
Fehlermeldung sagt auch klar, wer an diesem Fehler schuld ist, n&#228;mlich Elke.</p><p>Elke korrigiert also ihren Fehler. Nun kommt jedoch der Fehler, den Joe in die Funktion
eingebaut hat, zum Tragen. Dieser Fehler wird jedoch sofort gefunden und es wird korrekt
Joe die Schuld daran zugewiesen.</p><blockquote class="SCodeFlow"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="stt">"elke.rkt"</span></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"Joe.rkt"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rest-after: broke its contract</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">promised: "list?"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">produced: "not a list"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in: the range of</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">number?</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(listof number?)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(listof number?))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">contract from: /Users/klaus/Joe.rkt</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">blaming: /Users/klaus/Joe.rkt</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(assuming the contract is correct)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">at: /Users/klaus/Joe.rkt:3.24</span></p></td></tr></table></p><p>Wie diese Beispiele illustrieren, ist der Hauptvorteil von dynamisch &#252;berpr&#252;ften Signaturen und Contracts,
dass Fehler fr&#252;her gefunden werden und die Fehlermeldungen modular sind und es bei Verletzungen
einen klar benennbaren "Schuldigen" gibt. Wenngleich Fehler hierdurch fr&#252;her gefunden werden, so
werden die Fehler dennoch erst w&#228;hrend der Programmausf&#252;hrung gefunden. Da es im Allgemeinen unendlich
viele verschiedene Programmausf&#252;hrungen f&#252;r ein Programm gibt, kann man sich nie sicher sein, dass
nicht doch noch Contract-Verletzungen zur Laufzeit auftreten k&#246;nnnen.</p><p>Ein wichtiger Nachteil von Contracts ist, dass man nur solche Contracts ausdr&#252;cken kann, die auch
tats&#228;chlich berechnet werden k&#246;nnen. Eine Signatur wie</p><blockquote class="SCodeFlow"><p><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">[X] (list-of X) -&gt; (list-of X)</span></p></blockquote><p>erfordert es beispielsweise, dass man zur &#220;berpr&#252;fung dieses Contracts ein Pr&#228;dikat ben&#246;tigt, welches
&#252;berpr&#252;ft, ob ein Listenelement ein X ist. Dieses Pr&#228;dikat muss gegebenenfalls im Programm mit &#252;bergeben
und gegebenenfalls &#252;ber gro&#223;e "Entfernungen" durch das Programm "durchgeschleift" werden.</p><p>Au&#223;erdem k&#246;nnen Contracts offensichtlich nur Restriktionen &#252;berpr&#252;fen, f&#252;r die die relevanten
Informationen auch als Daten zur Verf&#252;gung stehen. Eine Datendefinition wie</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A temperature is a number that is larger than -273.15.</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. temperature in degrees Celsius</span></td></tr></table></blockquote><p>l&#228;sst sich nicht &#252;berpr&#252;fen, weil wir einer Zahl nicht ansehen k&#246;nnen, ob sie eine Temperatur repr&#228;sentiert.
Allerdings k&#246;nnen wir durch eine Strukturdefinition ein passendes Tag dazu definieren, welches dann
auch zur Laufzeit &#252;berpr&#252;fbar ist:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define-struct%29%29" class="RktStxLink" data-pltdoc="x">define-struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">temperature</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">d</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A temperature is: (make-temperature Number) where the number is larger than -273.15</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">interp. a temperature in degrees celsius</span></td></tr></table></blockquote><p>Ein pragmatischer Nachteil von dynamischen &#220;berpr&#252;fungen ist, dass diese die Laufzeit eines Programms
stark negativ beeinflussen k&#246;nnen. Deshalb gibt es in einigen Sprachen die M&#246;glichkeit, die dynamische
&#220;berpr&#252;fung abzustellen.</p><h4>12.4<tt>&nbsp;</tt><a name="(part._.Statisch_getypte_.Sprachen)"></a>Statisch getypte Sprachen</h4><p>Die letzte Variante, um Signaturen und Datendefinitionen durch die Sprache zu unterst&#252;tzen, ist
die Idee eines statischen Typsystems. In einem statischen Typsystem wird jedem Programmteil
<span class="emph">vor der Ausf&#252;hrung</span> ein Typ zugeordnet, und zwar so, dass der Typ eines zusammengesetzten
Programmteils nur von den Typen seiner Komponenten abh&#228;ngt (sogenannte <span class="emph">Kompositionalit&#228;t</span>).</p><p>Beispielsweise kann dem Ausdruck <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">e-1</span><span class="stt"> </span><span class="RktSym">e-2</span><span class="RktPn">)</span> der Typ <span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Number%29%29" class="RktStxLink" data-pltdoc="x">Number</a></span> zugeordnet werden
unter der Voraussetzung, dass <span class="RktSym">e-1</span> und <span class="RktSym">e-2</span> ebenfalls diesen Typ haben.</p><p>Statische Typsysteme zeichnen sich durch zwei wichtige Eigenschaften aus: 1) Falls ein
Programm den Typchecker durchl&#228;uft ("wohlgetypt" ist), so wird in allen (i.A. unendlich vielen)
m&#246;glichen Programmausf&#252;hrungen kein Typfehler auftreten. In dem Sinne sind statische Typen
viel m&#228;chtiger als Tests, weil diese immer nur eine kleine Zahl unterschiedlicher Programmausf&#252;hrungen
&#252;berpr&#252;fen k&#246;nnen. 2) Es gibt stets Programme, die vom Typchecker abgelehnt werden, obwohl
sie eigentlich ausgef&#252;hrt werden k&#246;nnten, ohne das ein Typfehler auftritt. Diese Eigenschaft
ist eine direkte Konsequenz des sogenannten "Theorem von Rice", welches aussagt, dass nichttriviale
Eigenschaften des Verhaltens von Programmen nicht entscheidbar sind.</p><p>DrRacket unterst&#252;tzt eine getypte Variante von Racket, Typed Racket. Hier ist unser
Beispiel von oben in Typed Racket:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._~3a%29%29" class="RktStxLink" data-pltdoc="x">:</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types-extra..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Listof%29%29" class="RktStxLink" data-pltdoc="x">Listof</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Listof%29%29" class="RktStxLink" data-pltdoc="x">Listof</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Wie wir sehen, gibt es in Typed Racket eine formale Syntax f&#252;r die Signatur von Funktionen.
Das Typsystem von Typed Racket ist so gestaltet, dass die Konsistenz der Funktion zur
angegebenen Signatur &#252;berpr&#252;ft werden kann, ohne das Programm bzw. einen Test auszuf&#252;hren.
Es kann also einmal, "once and for all", &#252;berpr&#252;ft werden, dass <span class="RktSym">rest-after</span> die
angegebene Signatur einhalten wird, und zwar f&#252;r alle Parameter die den angegebenen Typen
gen&#252;gen.</p><p>Diese Funktion kann nun wie in der Beginning Student Language aufgerufen werden:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktOut">- : (Listof Integer)</span></p></td></tr><tr><td><p><span class="RktRes">'(3 4)</span></p></td></tr></table></blockquote><p>Allerdings gibt es einen wichtigen Unterschied: Der Funktionsaufruf wird ebenfalls vor dem
Aufruf auf Konsistenz mit der Funktionssignatur &#252;berpr&#252;ft:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">"x"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">eval:5:0: Type Checker: type mismatch</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: Integer</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: String</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: 4</span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">"drei"</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">eval:6:0: Type Checker: type mismatch</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: Integer</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: String</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: 4</span></p></td></tr></table></blockquote><p>Dass diese &#220;berpr&#252;fung schon vor dem Aufruf stattfindet, erkennt man daran, dass die Typpr&#252;fung
eines Aufrufs auch dann gelingt, wenn der tats&#228;chliche Aufruf einen Laufzeitfehler generieren w&#252;rde.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/Exploring_Types.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._~3aprint-type%29%29" class="RktStxLink" data-pltdoc="x">:print-type</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2F%29%29" class="RktValLink" data-pltdoc="x">/</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktOut">(Listof Integer)</span></p></td></tr></table></blockquote><p>Auch die Pr&#252;fung der Funktion selber findet statt ohne die Funktion auszuf&#252;hren.
Ein Verstoss gegen die angegebene Signatur wird sofort angezeigt.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._~3a%29%29" class="RktStxLink" data-pltdoc="x">:</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types-extra..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Listof%29%29" class="RktStxLink" data-pltdoc="x">Listof</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Listof%29%29" class="RktStxLink" data-pltdoc="x">Listof</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._empty~3f%29%29" class="RktValLink" data-pltdoc="x">empty?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"not a list"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest-after</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">eval:9:0: Type Checker: type mismatch</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: (Listof Integer)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: String</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: xs</span></p></td></tr></table></blockquote><p>Der gro&#223;e Vorteil statischer Typpr&#252;fung ist, dass diese schon vor der Programmausf&#252;hrung
(beispielsweise beim Entwickler und nicht beim Kunden) gefunden werden und ein wohlgetyptes Programm
niemals Typfehler generieren wird. In der Theorie formalisiert man diese Eigenschaft h&#228;ufig so,
dass die Reduktionssemantik f&#252;r die getypte Sprache stets die Wohlgetyptheit erh&#228;lt, also
wenn ein Programm vor der Reduktion wohlgetypt ist, ist es das auch nach der Reduktion
(sogenanntes "Preservation" oder "Subject Reduction" Theorem) und wohlgetypte Programme, die
keine Werte sind, k&#246;nnen stets reduziert werden (sogenanntes "Progress" Theorem).</p><p>Der gr&#246;&#223;te Nachteil statischer Typpr&#252;fung ist, dass es stets Programme gibt, die vom Typchecker
abgelehnt werden, obwohl ihre Ausf&#252;hrung keinen Fehler ergeben w&#252;rde.</p><p><div class="SIntrapara">Hier ein kleines Programm, welches in BSL ohne Typfehler ausgef&#252;hrt wird:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3e%29%29" class="RktValLink" data-pltdoc="x">&gt;</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"a"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">2</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Das gleiche Programm wird in Typed Racket abgelehnt:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3e%29%29" class="RktValLink" data-pltdoc="x">&gt;</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"a"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">eval:10:0: Type Checker: type mismatch</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: Number</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: (U One String)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: "a"</span></p></td></tr></table></blockquote></div></p><p>Der Entwurf von Typsystemen, mit denen m&#246;glichst viele Programme &#252;berpr&#252;ft werden k&#246;nnen, ist
ein sehr aktiver Forschungszweig in der Informatik.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Quote_und_Unquote.html" title="backward to &quot;11 Quote und Unquote&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Informatik 1, WS 2023/24 Universität Tübingen&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lang-support-adts.html" title="forward to &quot;13 Sprachunterstützung für Algebraische Datentypen&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>